<!DOCTYPE html>
<html  lang=en>
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  
    
    <link rel="shortcut icon" href="/images/favicon.ico ">
    
    
    <link rel="icon" type="image/png" href="/images/favicon-android.png " sizes="192x192">
    
    
    <link rel="apple-touch-icon" href="/images/favicon-apple.png " sizes="180x180">
    
  
  <!-- title -->
  <title>Yu Peng blog 第一章：计算机系统漫游 </title>
  <!-- styles -->
  <!-- styles -->

<link rel="stylesheet" href="/styles/global.css">

  <!-- rss -->
  
<meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <header id="header">
  
  <nav class="menu menu--right">
  
    <a class="menu__item" href="/">主页</a>
    <a class="menu__item" href="/archives/">归档</a>
    <a class="menu__item" href="/categories/">专题</a>
    <a class="menu__item" href="/tags/">标签</a>
    <a class="menu__item" href="/works/">作品</a>
    <a class="menu__item" href="/about/">关于</a>
  </nav>
</header>
    <main>
      <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post__header">
  <h1 class="post__title">第一章：计算机系统漫游</h1>
  
  
  <div class="post__meta">
    
<time class="post__date" datetime="2023-08-15T12:08:57.632Z" itemprop="datePublished">
  
  <i class="blogfont">&#xedff;</i>
  
  2023-08-15 20:08:57
</time>

    
<div class="post__category">
  <i class="blogfont">&#xe62d;</i>
  <a class="category-link" href="/categories/csapp/">csapp</a>
</div>
  

    
<div class="post__tag">
  <i class="blogfont">&#xe7ec;</i>
  <a class="tag-link-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a>
</div>


    <div id="/2023/08/15/csapp/chapter1/index/" class="leancloud_visitors post__stat" data-flag-title="第一章：计算机系统漫游">
  <i class="blogfont">&#xe672;</i>
  <span class="leancloud-visitors-count">loading...</span>
</div>
  </div>
</header>
  <aside class="post__aside">
  <div class="post__actions">
    <a id="backTop" class="post__top" href="javascript:">
      <i class="blogfont">&#xe6b1;</i><!-- Top -->
    </a>
    <a id="share" class="post__share" href="javascript:">
      <i class="blogfont">&#xe6c1;</i>
    </a>
  </div>
  <ol class="post__toc"><li class="post__toc-item post__toc-level-1"><a class="post__toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8"><span class="post__toc-text">计算机系统漫游</span></a><ol class="post__toc-child"><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#1-1-%E4%BF%A1%E6%81%AF%E5%B0%B1%E7%AE%97%E4%BD%8D-%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="post__toc-text">1.1 信息就算位+上下文</span></a></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#1-2-%E7%A8%8B%E5%BA%8F%E8%A2%AB%E5%85%B6%E4%BB%96%E7%A8%8B%E5%BA%8F%E7%BF%BB%E8%AF%91%E6%88%90%E4%B8%8D%E5%90%8C%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="post__toc-text">1.2 程序被其他程序翻译成不同的格式</span></a></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#1-3-%E4%BA%86%E8%A7%A3%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E6%98%AF%E6%9C%89%E5%A4%A7%E7%9B%8A%E5%A4%84%E7%9A%84"><span class="post__toc-text">1.3 了解编译系统如何工作是有大益处的</span></a></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#1-4-%E5%A4%84%E7%90%86%E5%99%A8%E8%AF%BB%E5%B9%B6%E8%A7%A3%E9%87%8A%E5%82%A8%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="post__toc-text">1.4 处理器读并解释储存在内存中的指令</span></a><ol class="post__toc-child"><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#1-4-1-%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90"><span class="post__toc-text">1.4.1 系统的硬件组成</span></a><ol class="post__toc-child"><li class="post__toc-item post__toc-level-4"><a class="post__toc-link" href="#%E6%80%BB%E7%BA%BF"><span class="post__toc-text">总线</span></a></li><li class="post__toc-item post__toc-level-4"><a class="post__toc-link" href="#I-x2F-O-%E8%AE%BE%E5%A4%87"><span class="post__toc-text">I&#x2F;O 设备</span></a></li><li class="post__toc-item post__toc-level-4"><a class="post__toc-link" href="#%E4%B8%BB%E5%AD%98"><span class="post__toc-text">主存</span></a></li><li class="post__toc-item post__toc-level-4"><a class="post__toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8"><span class="post__toc-text">处理器</span></a></li></ol></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#1-4-2-%E8%BF%90%E8%A1%8Chello%E7%A8%8B%E5%BA%8F"><span class="post__toc-text">1.4.2 运行hello程序</span></a></li></ol></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#1-5-%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E8%87%B3%E5%85%B3%E9%87%8D%E8%A6%81"><span class="post__toc-text">1.5 高速缓存至关重要</span></a></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#1-6-%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87%E5%BD%A2%E6%88%90%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="post__toc-text">1.6 存储设备形成层次结构</span></a></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#1-7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%A1%AC%E4%BB%B6"><span class="post__toc-text">1.7 操作系统管理硬件</span></a><ol class="post__toc-child"><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#1-7-1-%E8%BF%9B%E7%A8%8B"><span class="post__toc-text">1.7.1 进程</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#1-7-2-%E7%BA%BF%E7%A8%8B"><span class="post__toc-text">1.7.2 线程</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#1-7-3-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="post__toc-text">1.7.3 虚拟内存</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#1-7-4-%E6%96%87%E4%BB%B6"><span class="post__toc-text">1.7.4 文件</span></a></li></ol></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#1-8-%E7%B3%BB%E7%BB%9F%E4%B9%8B%E9%97%B4%E5%88%A9%E7%94%A8%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="post__toc-text">1.8 系统之间利用网络通信</span></a></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#1-9-%E9%87%8D%E8%A6%81%E4%B8%BB%E9%A2%98"><span class="post__toc-text">1.9 重要主题</span></a><ol class="post__toc-child"><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#1-9-1-Amdahl-%E5%AE%9A%E5%BE%8B"><span class="post__toc-text">1.9.1 Amdahl 定律</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#1-9-1-%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C"><span class="post__toc-text">1.9.1 并发和并行</span></a><ol class="post__toc-child"><li class="post__toc-item post__toc-level-4"><a class="post__toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E7%BA%A7%E5%B9%B6%E5%8F%91"><span class="post__toc-text">1. 线程级并发</span></a></li><li class="post__toc-item post__toc-level-4"><a class="post__toc-link" href="#2-%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C"><span class="post__toc-text">2. 指令级并行</span></a></li><li class="post__toc-item post__toc-level-4"><a class="post__toc-link" href="#3-%E5%8D%95%E6%8C%87%E4%BB%A4%E3%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E5%B9%B6%E8%A1%8C"><span class="post__toc-text">3. 单指令、多数据并行</span></a></li></ol></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#1-9-3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%8A%BD%E8%B1%A1%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="post__toc-text">1.9.3 计算机系统中抽象的重要性</span></a></li></ol></li></ol></li></ol>
</aside>
  <div class="post__content" itemprop="articleBody">
    <h1 id="计算机系统漫游"><a href="#计算机系统漫游" class="headerlink" title="计算机系统漫游"></a>计算机系统漫游</h1><p><code>c</code>语言<code>hello world 程序</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过跟踪<code>hello</code>程序的生命周期来开始对系统的学习-从被程序员创建开始，到系统上运行，输出简单的信息，然后终止。</p>
<h2 id="1-1-信息就算位-上下文"><a href="#1-1-信息就算位-上下文" class="headerlink" title="1.1 信息就算位+上下文"></a>1.1 信息就算位+上下文</h2><p><code>hello</code> 程序的生命周期是从一个源程序开始的，即程序员通过编辑器创建并保存的文件，文件名是 <code>hello.c</code> 。源程序实际上就是一个由0和1 组成的位（又称比特）序列，八个位被称之为一组，称为字节。每个字节都表示程序中的某些文本字符。<br>大部分的现代计算机系统都使用 <code>ASCII</code> 标准来表示文本字符，这种方式实际上就是用一个唯一的单字节大小的整数来表示每一个字符。<br><code>hello.c</code> 程序是以字节的方式存储在文件中的。没个字节有一个整数值，对应于某些字符。像 <code>hello.c</code> 只有 <code>ASCLII</code> 字符构成的文件称为文本文件，所有其他文件都称之为二进制文件。<br><code>hello.c</code> 的表示方式说明了一个基本思想：系统中所有的信息——包括磁盘文件、内存中的程序，内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。<br>作为程序员，我们需要了解数字的机器表示方式，因为它们于实际的整数和实数时不同的。</p>
<h2 id="1-2-程序被其他程序翻译成不同的格式"><a href="#1-2-程序被其他程序翻译成不同的格式" class="headerlink" title="1.2 程序被其他程序翻译成不同的格式"></a>1.2 程序被其他程序翻译成不同的格式</h2><p><code>hello</code> 程序的生命周期时从一个高级C语言程序开始的。因此这种程序能够被人读懂。然而，为了在系统上运行 <code>hello.c</code> 程序，每条 C 语句都必须被其他程序转化为一些列的低级机器语言指令。然后这些指令按照一种可执行目标的格式打包好，并以二进制磁盘文件的形式存放起来。目标程序也称为可执行目标文件。<br>在 <code>Unix</code> 系统上，从源文件到目标文件的转化时由编译器驱动程序完成的：</p>
<blockquote>
<p>gcc -o helle hello.c </p>
</blockquote>
<p>在这里，<code>GCC</code> 编译器驱动程序读取源程序文件 <code>hello.c</code>,并把它翻译成一个可执行的目标文件 <code>hello</code>。这个翻译工作可以分为四个阶段完成, 如下图所示。</p>
<p><img src="/image/caspp/chapter1/1-1.jpg"></p>
<p>预处理器、编译器、汇编器和链接器 一起构成了编译系统，下面对每个步骤分别进行解析：</p>
<ul>
<li>预处理阶段：预处理器 cpp 根据以字符 # 开头的命令，修改原始的 C 程序，比如 Hello.c 中第一行 #include&lt;studio.h&gt; 命令告诉预处理器读取系统文件 stdio.h 的内容，并把它直接插入到程序中。结果就得到另一个 C 程序，通常是以 .i 作为文件扩展名。</li>
<li>编译阶段：编译器 ccl 将文本文件 hello.i 翻译成文本文件 hello.s，它包含一个汇编语言程序，汇编语言程序中的每条语句都以一种标准的文本格式确切的描述一条低级机器语言指令。汇编语言能为不同高级语言的不同编译器提供通用的输出语言。</li>
<li>汇编阶段：汇编器 as 将hello.s 翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在目标文件 hello.o 中，hello.o 文件是一个二进制文件，它的字节编码是机器预言指令而不是字符。如果我们用文本编辑器打开 hello.o 文件，将会是一堆乱码。</li>
<li>链接阶段：在 hello.c 程序中，我们看到程序调用了 printf 函数，它是每个 C 编译器都会提供的标准 C 库中的一个函数。printf 函数存在于一个名为 printf.o 的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的 hello.o 程序中。链接器 ld 就是负责处理这种合并，结果就得到一个 hello 文件，它是一个可执行目标程序，可以被加载到内存中，由系统运行。</li>
</ul>
<h2 id="1-3-了解编译系统如何工作是有大益处的"><a href="#1-3-了解编译系统如何工作是有大益处的" class="headerlink" title="1.3 了解编译系统如何工作是有大益处的"></a>1.3 了解编译系统如何工作是有大益处的</h2><p>对于像<code>hello.c</code>这样简单的程序，我们可以依靠编译系统生成有效的机器代码。但是，有一些重要的原因促使程序员必须知道编译系统是如何工作的。</p>
<ul>
<li>优化程序性能</li>
<li>理解链接时出现的错误</li>
<li>避免安全漏洞</li>
</ul>
<h2 id="1-4-处理器读并解释储存在内存中的指令"><a href="#1-4-处理器读并解释储存在内存中的指令" class="headerlink" title="1.4 处理器读并解释储存在内存中的指令"></a>1.4 处理器读并解释储存在内存中的指令</h2><p>此刻，<code>hello.c</code> 源程序已经被编译系统翻译成了可执行目标文件hello, 并存储放在磁盘上。要想在<code>Unix</code>系统上运行该可执行文件，我们将它的文件名输入到称为 <code>shell</code> 的应用程序中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">./hello</span></span><br><span class="line">hello,world!</span><br></pre></td></tr></table></figure>
<p>shell是一个命令行解释器，它输出一个提示符，等待你输入一个命令行。然后执行这个命令。如果该命令行的第一个单词不是一个内置的外壳命令，那么外壳就会假设这是一个可执行文件的名字，它将加载并运行这个文件。 所以在此例中，外壳将加载并运行hello程序。然后等待程序终止。hello程序在屏幕上输出它的信息，然后终止。外壳随后输出一个提示符，等待下一个输入的命令行。</p>
<h3 id="1-4-1-系统的硬件组成"><a href="#1-4-1-系统的硬件组成" class="headerlink" title="1.4.1 系统的硬件组成"></a>1.4.1 系统的硬件组成</h3><p>为了理解运行 <code>hello</code> 程序时发生了什么，我们需要了解一个典型系统的硬件组织，如下图所示。</p>
<p><img src="/image/caspp/chapter1/1-2.jpg"></p>
<h4 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h4><p>贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字（word）。字中的字节数（即字长）是一个基本的系统参数，各个系统中都不尽相同。现在的大多数机器字长要么是 4 个字节（32 位），要么是 8 个字节（64 位）。本书中，我们不对字长做任何固定的假设。相反，我们将在需要明确定义的上下文中具体说明一个“字”是多大。</p>
<h4 id="I-x2F-O-设备"><a href="#I-x2F-O-设备" class="headerlink" title="I&#x2F;O 设备"></a>I&#x2F;O 设备</h4><p>I&#x2F;O（输入&#x2F;输出）设备是系统与外部世界的联系通道。我们的示例系统包括四个 I&#x2F;O 设备：作为用户输入的键盘和鼠标，作为用户输出的是显示器，以及用于长期存储数据和程序的磁盘驱动器（简单地说就是磁盘）。最开始，可执行程序 hello 就存放在磁盘上。  </p>
<p>每个 I&#x2F;O 设备都通过一个控制器或适配器与 I&#x2F;O 总线相连。控制器和适配器之间的区别主要在于它们的封装方式。控制器是 I&#x2F;O 设备本身或者系统的主印制电路板（通常称作主板）上的芯片组。而适配器则是一块插在主板插槽上的卡。无论如何，它们的功能都是在 I&#x2F;O 总线和 I&#x2F;O 设备之间传递信息。  </p>
<h4 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h4><p>主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是是一组动态随机存取存储器（DRAM）芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的。一般来说，组成程序的每条机器指令都由不同数量的字节构成。与 C 程序变量相对应的数据项大小是根据类型变化的。比如，在运行 Linux 的 x86-64 机器上，short 类型的数据需要两个字节，int 和 float 类型需要 4 个字节，而 long 和 double 类型需要 8 个字节。  </p>
<h4 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h4><p>中央处理单元（CPU），简称处理器，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器（PC）。在任何时刻，PC 都指向主存中的某条机器语言指令（即含有该条指令的地址）。</p>
<p>从系统通电开始，直到系统断电，处理器一致在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。处理器看上去是按照一个非常简单的指令执行模型来操作的，这个模型是由指令集架构决定的。在这个模型中，指令按照严格的顺序执行，而执行一条指令包含一系列步骤。处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后再更新 PC，使其指向下一条指令，而这条指令并不一定和在内存中刚刚执行的指令相邻。</p>
<p>这样的简单操作并不多，它们围绕着主存、寄存器文件（register file）和算术&#x2F;逻辑单元（ALU）进行。寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALU 计算新的数据和地址值。下面是一些简单操作的例子，CPU 在指令的要求下可能会执行这些操作。</p>
<ul>
<li>加载：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容。</li>
<li>存储：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容。</li>
<li>操作：把两个寄存器的内容复制到 ALU，ALU 对这两个字做算术运算，并将结构存放到一个寄存器中，以覆盖该寄存器中原来的内容。</li>
<li>跳转：从指令本身中抽取一个字，并将这个字复制到程序计数器（PC）中，以覆盖 PC 中原来的值。</li>
</ul>
<p>处理器看上去是它的指令集架构的简单实现，但是实际上现代处理器使用了非常复杂的机制来加速程序的执行。因此，我们将处理器的指令集架构和处理器的微体系结构区分开来：指令集架构描述的是每条机器代码指令的效果；而微体系结构描述的是处理器实际上是如何实现的。 </p>
<h3 id="1-4-2-运行hello程序"><a href="#1-4-2-运行hello程序" class="headerlink" title="1.4.2 运行hello程序"></a>1.4.2 运行<code>hello</code>程序</h3><p>前面简述了系统的硬件组成和操作，现在介绍运行程序时到底发生了什么。</p>
<p>初始时，shell 程序执行它的指令，等待我们输入一个命令。当我们在键盘上输入字符串 “.&#x2F;hello” 后，shell 程序将字符逐一读入寄存器，再把它放在内存中，如下图所示。</p>
<p><img src="/image/caspp/chapter1/1-3.jpg"></p>
<p>当我们再键盘上敲回车键时,<code>shell</code> 程序就知道我们已经结束了命令的输入。然后 <code>shell</code> 执行一系列指令来加载可执行的 <code>hello</code> 文件， 这些指令将 <code>hello</code> 目标文件中的代码和数据从磁盘复制到主存。数据包括最终会被输出到字符串 “hello, world!\n”。<br>利用之际存储器读取技术，数据可以不通过处理器而直接从磁盘到达主存。如下图所示。</p>
<p><img src="/image/caspp/chapter1/1-4.jpg"></p>
<p>一旦目标文件 <code>hello</code> 中的代码和数据被加载到主存，处理器就开始执行 <code>hello</code> 程序的<code>main</code> 程序中的机器语言指令。这些指令将”hello, world!\n”字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最近显示再屏幕上。这个步骤如下图所示。</p>
<p><img src="/image/caspp/chapter1/1-5.jpg"></p>
<h2 id="1-5-高速缓存至关重要"><a href="#1-5-高速缓存至关重要" class="headerlink" title="1.5 高速缓存至关重要"></a>1.5 高速缓存至关重要</h2><p>这个简单的示例揭示了一个重要的问题，即系统花费了大量的时间把信息从一个地方挪到另一个地方。hello 程序的机器指令最初是存放在磁盘上，当程序加载时，它们被复制到主存；当处理器运行程序时，指令又从主存复制到处理器。相似地，数据串 “hello, world\n” 开始时在磁盘上，然后被复制到主存，最后从主存上复制到显示设备。从程序员的角度来看，这些复制就是开销，减慢了程序“真正”的工作。因此，系统设计者的一个主要目标就是使这些复制操作尽可能快地完成。如下图所示。</p>
<p><img src="/image/caspp/chapter1/1-6.jpg"></p>
<p>根据机械原理，较大的存储设备要比较小的存储设备运行得慢，而快速设备的造价远高于同类的低速设备。  </p>
<p>类似地，一个典型的寄存器文件只存储几百字节的信息，而主存里可存放几十亿字节。然而，处理器从寄存器文件中读数据比从主存中读取几乎要快 100 倍。更麻烦的是，随着这些年半导体技术的进步，这种处理器与主存之间的差距还在持续增大。加快处理器的运行速度比加快主存的运行速度要容易和便宜得多。 针对这种处理器与主存之间的差异，系统设计者采用了更小更快的存储设备，称为高速缓存存储器（cache memory，简称为 cache 或高速缓存），作为暂时的集结区域，存放处理器近期可能会需要的信息。下图展示了一个典型系统中的高速缓存存储器。位于处理器芯片上的 L1 高速缓存的容量可以达到数万字节，访问速度几乎和访问寄存器文件一样快。一个容量为数十万到数百万字节的更大的 L2 高速缓存通过一条特殊的总线连接到处理器。进程访问 L2 高速缓存的时间要比访问 L1 高速缓存的时间长 5 倍，但是这仍然比访问主存的时间快 5~10 倍。L1 和 L2 高速缓存是用一种叫做静态随机访问存储器（SRAM）的硬件技术实现的。比较新的、处理能力更强大的系统甚至有三级高速缓存∶L1、L2 和 L3。系统可以获得一个很大的存储器，同时访问速度也很快，原因是利用了高速缓存的局部性原理，即程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。</p>
<p><img src="/image/caspp/chapter1/1-7.jpg"></p>
<h2 id="1-6-存储设备形成层次结构"><a href="#1-6-存储设备形成层次结构" class="headerlink" title="1.6 存储设备形成层次结构"></a>1.6 存储设备形成层次结构</h2><p>在处理器和一个较大较慢的设备（例如主存）之间插入一个更小更快的存储设备（例如高速缓存）的想法已经成为一个普遍的观念。实际上，每个计算机系统中的存储设备都被组织成了一个存储器层次结构，如图 1-9 所示。在这个层次结构中，从上至下，设备的访问速度越来越慢、容量越来越大，并且每字节的造价也越来越便宜。寄存器文件在层次结构中位于最顶部，也就是第 0 级或记为 L0。这里我们展示的是三层高速缓存 L1 到 L3，占据存储器层次结构的第 1 层到第 3 层。主存在第 4 层，以此类推。</p>
<p><img src="/image/caspp/chapter1/1-8.jpg"></p>
<p>存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。因此，寄存器文件就是 L1 的高速缓存，L1 是 L2 的高速缓存，L2 是 L3 的高速缓存，L3 是主存的高速缓存，而主存又是磁盘的高速缓存。在某些具有分布式文件系统的网络系统中，本地磁盘就是存储在其他系统中磁盘上的数据的高速缓存。 正如可以运用不同的高速缓存的知识来提高程序性能一样，程序员同样可以利用对整个存储器层次结构的理解来提高程序性能。 </p>
<h2 id="1-7-操作系统管理硬件"><a href="#1-7-操作系统管理硬件" class="headerlink" title="1.7 操作系统管理硬件"></a>1.7 操作系统管理硬件</h2><p>让我们回到 hello 程序的例子。当 shell 加载和运行 hello 程序时，以及 hello 程序输出自己的消息时，shell  和 hello 程序都没有直接访问键盘、显示器、磁盘或者主存。取而代之的是，它们依靠操作系统提供的服务。我们可以把操作系统看成是应用程序和硬件之间插入的一层软件，如下图所示。所有应用程序对硬件的操作尝试都必须通过操作系统。</p>
<p><img src="/image/caspp/chapter1/1-9.jpg"></p>
<p>操作系统有两个基本功能∶（1）防止硬件被失控的应用程序滥用；（2）向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。如下图所示，文件是对 I&#x2F;O 设备的抽象表示，虚拟内存是对主存和磁盘 I&#x2F;O 设备的抽象表示，进程则是对处理器、主存和 I&#x2F;O 设备的抽象表示。我们将依次讨论每种抽象表示。</p>
<p><img src="/image/caspp/chapter1/1-10.jpg"></p>
<h3 id="1-7-1-进程"><a href="#1-7-1-进程" class="headerlink" title="1.7.1 进程"></a>1.7.1 进程</h3><p>像 hello 这样的程序在现代系统上运行时，操作系统会提供一种假象，就好像系统上只有这个程序在运行。程序看上去是独占地使用处理器、主存和 I&#x2F;O 设备。处理器看上去就像在不间断地一条接一条地执行程序中的指令，即该程序的代码和数据是系统内存中唯一的对象。这些假象是通过进程的概念来实现的，进程是计算机科学中最重要和最成功的概念之一。</p>
<p>进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。而并发运行，则是说一个进程的指令和另一个进程的指令是交错执行的。在大多数系统中，需要运行的进程数是多于可以运行它们的 CPU 个数的。传统系统在一个时刻只能执行一个程序，而先进的多核处理器同时能够执行多个程序。无论是在单核还是多核系统中，一个 CPU 看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。操作系统实现这种交错执行的机制称为上下文切换。为了简化讨论，我们只考虑包含一个 CPU 的单处理器系统的情况。</p>
<p>操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文，包括许多信息，比如 PC 和寄存器文件的当前值，以及主存的内容。在任何一个时刻，单处理器系统都只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程。新进程就会从它上次停止的地方开始。下图展示了示例 hello 程序运行场景的基本理念。</p>
<p>示例场景中有两个并发的进程∶shell 进程和 hello 进程。最开始，只有 shell 进程在运行，即等待命令行上的输入。当我们让它运行 hello 程序时，shell 通过调用一个专门的函数，即系统调用，来执行我们的请求，系统调用会将控制权传递给操作系统。操作系统保存 shell 进程的上下文，创建一个新的 hello 进程及其上下文，然后将控制权传给新的 hello 进程。hello 进程终止后，操作系统恢复 shell 进程的上下文，并将控制权传回给它，shell 进程会继续等待下一个命令行输入。</p>
<p>如下图示，从一个进程到另一个进程的转换是由操作系统内核（kernel）管理的。内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的系统调用（system call）指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。注意，内核不是一个独立的进程。相反，它是系统管理全部进程所用代码和数据结构的集合。</p>
<p><img src="/image/caspp/chapter1/1-11.jpg"></p>
<p>实现进程这个抽象概念需要低级硬件和操作系统软件之间的紧密合作。 </p>
<h3 id="1-7-2-线程"><a href="#1-7-2-线程" class="headerlink" title="1.7.2 线程"></a>1.7.2 线程</h3><p>尽管通常我们认为一个进程只有单一的控制流，但是在现代系统中，一个进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。由于网络服务器中对并行处理的需求，线程成为越来越重要的编程模型，因为多线程之间比多进程之间更容易共享数据，也因为线程一般来说都比进程更高效。当有多处理器可用的时候，多线程也是一种使得程序可以运行得更快的方法， </p>
<h3 id="1-7-3-虚拟内存"><a href="#1-7-3-虚拟内存" class="headerlink" title="1.7.3 虚拟内存"></a>1.7.3 虚拟内存</h3><p>虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。如下图所示的是 Linux 进程的虚拟地址空间（其他 Unix 系统的设计也与此类似）。在 Linux 中，地址空间最上面的区域是保留给操作系统中的代码和数据的，这对所有进程来说都是一样。地址空间的底部区域存放用户进程定义的代码和数据。请注意，图中的地址是从下往上增大的。</p>
<p><img src="/image/caspp/chapter1/1-12.jpg"></p>
<p>每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。在本书的后续章节你将学到更多有关这些区的知识，但是先简单了解每一个区是非常有益的。我们从最低的地址开始，逐步向上介绍。 </p>
<ul>
<li>程序代码和数据。对所有的进程来说，代码是从同一固定地址开始，紧接着的是和 C 全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的，在示例中就是可执行文件 hello。在第 7 章我们研究链接和加载时，你会学习更多有关地址空间的内容。</li>
<li>堆。代码和数据区后紧随着的是运行时堆。代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像 malloc 和 free 这样的 C 标准库函数时，堆可以在运行时动态地扩展和收缩。在第 9 章学习管理虚拟内存时，我们将更详细地研究堆。 </li>
<li>共享库。大约在地址空间的中间部分是一块用来存放像 C 标准库和数学库这样的共享库的代码和数据的区域。共享库的概念非常强大，也相当难懂。在第 7 章介绍动态链接时，将学习共享库是如何工作的。 </li>
<li>栈。位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。特别地，每次我们调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩。在第 3 章中将学习编译器是如何使用栈的。</li>
<li>内核虚拟内存。地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作。</li>
</ul>
<p>虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互，包括对处理器生成的每个地址的硬件翻译。基本思想是把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。第 9 章将解释它如何工作，以及为什么对现代系统的运行如此重要。</p>
<h3 id="1-7-4-文件"><a href="#1-7-4-文件" class="headerlink" title="1.7.4 文件"></a>1.7.4 文件</h3><p>文件就是字节序列，仅此而已。每个I&#x2F;O设备，包括磁盘、键盘、显示器，甚至网络，都可以看成是文件。系统中的所有输入输出都是通过使用一小组称为 Unix I&#x2F;O 的系统函数调用读写文件来实现的。<br>文件这个简单而精致的概念是非常强大的，因为它向应用程序提供了一个统一的视图，来看待系统中可能含有的所有各式各样的 I&#x2F;O 设备。例如，处理磁盘文件内容的应用程序员可以非常幸福，因为他们无须了解具体的磁盘技术。进一步说，同一个程序可以在使用不同磁盘技术的不同系统上运行。</p>
<h2 id="1-8-系统之间利用网络通信"><a href="#1-8-系统之间利用网络通信" class="headerlink" title="1.8 系统之间利用网络通信"></a>1.8 系统之间利用网络通信</h2><p>系统漫游至此，我们一直是把系统视为一个孤立的硬件和软件的集合体。实际上，现代系统经常通过网络和其他系统连接到一起。从一个单独的系统来看，网络可视为一个 I&#x2F;O 设备，下图所示。当系统从主存复制一串字节到网络适配器时，数据流经过网络到达另一台机器，而不是比如说到达本地磁盘驱动器。相似地，系统可以读取从其他机器发送来的数据，并把数据复制到自己的主存。</p>
<p><img src="/image/caspp/chapter1/1-13.jpg"></p>
<p>随着 Internet 这样的全球网络的出现，从一台主机复制信息到另外一台主机已经成为计算机系统最重要的用途之一。比如，像电子邮件、即时通信、万维网、FTP 和 telnet 这样的应用都是基于网络复制信息的功能。 回到 hello 示例，我们可以使用熟悉的 telnet 应用在一个远程主机上运行 hello 程序。假设用本地主机上的 telnet 客户端连接远程主机上的 telnet 服务器。在我们登录到远程主机并运行 shell 后，远端的 shell 就在等待接收输入命令。此后在远端运行 hello 程序包括如下图所示的五个基本步骤。</p>
<p><img src="/image/caspp/chapter1/1-14.jpg"></p>
<p>当我们在 telnet 客户端键入 “hello” 字符串并敲下回车键后，客户端软件就会将这个字符串发送到 telnet 的服务器。telnet 服务器从网络上接收到这个字符串后，会把它传递给远端 shell 程序。接下来，远端 shell 运行 hello 程序，并将输出行返回给 telnet 服务器。最后，telnet 服务器通过网络把输出串转发给 telnet 客户端，客户端就将输出串输出到我们的本地终端上。 这种客户端和服务器之间交互的类型在所有的网络应用中是非常典型的。</p>
<h2 id="1-9-重要主题"><a href="#1-9-重要主题" class="headerlink" title="1.9 重要主题"></a>1.9 重要主题</h2><p>在此，小结一下我们旋风式的系统漫游。这次讨论得出一个很重要的观点，那就是系统不仅仅只是硬件。系统是硬件和系统软件互相交织的集合体，它们必须共同协作以达到运行应用程序的最终目的。本书的余下部分会讲述硬件和软件的详细内容，通过了解这些详细内容，你可以写出更快速、更可靠和更安全的程序。</p>
<h3 id="1-9-1-Amdahl-定律"><a href="#1-9-1-Amdahl-定律" class="headerlink" title="1.9.1 Amdahl 定律"></a>1.9.1 Amdahl 定律</h3><p>Gene Amdahl，计算领域的早期先锋之一，对提升系统某一部分性能所带来的效果做出了简单却有见地的观察。这个观察被称为 Amdahl 定律（Amdahl’s law）。该定律的主要思想是，当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。 </p>
<h3 id="1-9-1-并发和并行"><a href="#1-9-1-并发和并行" class="headerlink" title="1.9.1 并发和并行"></a>1.9.1 并发和并行</h3><p>数字计算机的整个历史中，有两个需求是驱动进步的持续动力：一个是我们想要计算机做得更多，另一个是我们想要计算机运行得更快。当处理器能够同时做更多的事情时，这两个因素都会改进。我们用的术语并发（concurrency）是一个通用的概念，指一个同时具有多个活动的系统；而术语并行（parallelism）指的是用并发来使一个系统运行得更快。并行可以在计算机系统的多个抽象层次上运用。在此，我们按照系统层次结构中由高到低的顺序重点强调三个层次。</p>
<h4 id="1-线程级并发"><a href="#1-线程级并发" class="headerlink" title="1. 线程级并发"></a>1. 线程级并发</h4><p>构建在进程这个抽象之上，我们能够设计出同时有多个程序执行的系统，这就导致了并发。使用线程，我们甚至能够在一个进程中执行多个控制流。自 20 世纪 60 年代初期出现时间共享以来，计算机系统中就开始有了对并发执行的支持。传统意义上，这种并发执行只是模拟出来的，是通过使一台计算机在它正在执行的进程间快速切换来实现的，就好像一个杂耍艺人保持多个球在空中飞舞一样。这种并发形式允许多个用户同时与系统交互，例如，当许多人想要从一个 Web 服务器获取页面时。它还允许一个用户同时从事多个任务，例如，在一个窗口中开启 Web 浏览器，在另一窗口中运行字处理器，同时又播放音乐。在以前，即使处理器必须在多个任务间切换，大多数实际的计算也都是由一个处理器来完成的。这种配置称为单处理器系统。</p>
<p>当构建一个由单操作系统内核控制的多处理器组成的系统时，我们就得到了一个多处理器系统。其实从 20 世纪 80 年代开始，在大规模的计算中就有了这种系统，但是直到最近，随着多核处理器和超线程（hyperthreading）的出现，这种系统才变得常见。下图给出了这些不同处理器类型的分类。</p>
<p><img src="/image/caspp/chapter1/1-15.jpg"></p>
<p>多核处理器是将多个 CPU（称为“核”）集成到一个集成电路芯片上。 下图描述的是一个典型多核处理器的组织结构，其中微处理器芯片有 4 个 CPU 核，每个核都有自己的 L1 和 L2 高速缓存，其中的 L1 高速缓存分为两个部分——一个保存最近取到的指令，另一个存放数据。这些核共享更高层次的高速缓存，以及到主存的接口。工业界的专家预言他们能够将几十个、最终会是上百个核做到一个芯片上。</p>
<p><img src="/image/caspp/chapter1/1-16.jpg"></p>
<p>超线程，有时称为同时多线程（simultaneous multi-threading），是一项允许一个 CPU 执行多个控制流的技术。它涉及 CPU 某些硬件有多个备份，比如程序计数器和寄存器文件，而其他的硬件部分只有一份，比如执行浮点算术运算的单元。常规的处理器需要大约 20000 个时钟周期做不同线程间的转换，而超线程的处理器可以在单个周期的基础上决定要执行哪一个线程。这使得 CPU 能够更好地利用它的处理资源。比如，假设一个线程必须等到某些数据被装载到高速缓存中，那 CPU 就可以继续去执行另一个线程。举例来说，Intel Core i7 处理器可以让每个核执行两个线程，所以一个 4 核的系统实际上可以并行地执行 8 个线程。</p>
<p>多处理器的使用可以从两方面提高系统性能。首先，它减少了在执行多个任务时模拟并发的需要。正如前面提到的，即使是只有一个用户使用的个人计算机也需要并发地执行多个活动。其次，它可以使应用程序运行得更快，当然，这必须要求程序是以多线程方式来书写的，这些线程可以并行地高效执行。因此，虽然并发原理的形成和研究已经超过 50 年的时间了，但是多核和超线程系统的出现才极大地激发了一种愿望，即找到书写应用程序的方法利用硬件开发线程级并行性。第 12 章会更深入地探讨并发，以及使用并发来提供处理器资源的共享，使程序的执行允许有更多的并行。</p>
<h4 id="2-指令级并行"><a href="#2-指令级并行" class="headerlink" title="2. 指令级并行"></a>2. 指令级并行</h4><p>在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为指令级并行。早期的微处理器，如 1978 年的 Intel 8086，需要多个（通常是 3～10 个）时钟周期来执行一条指令。最近的处理器可以保持每个时钟周期 2～4 条指令的执行速率。其实每条指令从开始到结束需要长得多的时间，大约 20 个或者更多周期，但是处理器使用了非常多的聪明技巧来同时处理多达 100 条指令。在第 4 章中，我们会研究流水线（pipelining）的使用。在流水线中，将执行一条指令所需要的活动划分成不同的步骤，将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤。这些阶段可以并行地操作，用来处理不同指令的不同部分。我们会看到一个相当简单的硬件设计，它能够达到接近于一个时钟周期一条指令的执行速率。</p>
<p>如果处理器可以达到比一个周期一条指令更快的执行速率，就称之为超标量（super-scalar）处理器。大多数现代处理器都支持超标量操作。第 5 章中，我们将描述超标量处理器的高级模型。应用程序员可以用这个模型来理解程序的性能。然后，他们就能写出拥有更高程度的指令级并行性的程序代码，因而也运行得更快。</p>
<h4 id="3-单指令、多数据并行"><a href="#3-单指令、多数据并行" class="headerlink" title="3. 单指令、多数据并行"></a>3. 单指令、多数据并行</h4><p>在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即 SIMD 并行。例如，较新几代的 Intel 和 AMD 处理器都具有并行地对 8 对单精度浮点数（C 数据类型 float）做加法的指令。</p>
<p>提供这些 SIMD 指令多是为了提高处理影像、声音和视频数据应用的执行速度。虽然有些编译器会试图从 C 程序中自动抽取 SIMD 并行性，但是更可靠的方法是用编译器支持的特殊的向量数据类型来写程序，比如 GCC 就支持向量数据类型。作为对第 5 章中比较通用的程序优化描述的补充，我们在网络旁注 OPT：SIMD 中描述了这种编程方式。</p>
<h3 id="1-9-3-计算机系统中抽象的重要性"><a href="#1-9-3-计算机系统中抽象的重要性" class="headerlink" title="1.9.3 计算机系统中抽象的重要性"></a>1.9.3 计算机系统中抽象的重要性</h3><p>抽象的使用是计算机科学中最为重要的概念之一。例如，为一组函数规定一个简单的应用程序接口（API）就是一个很好的编程习惯，程序员无须了解它内部的工作便可以使用这些代码。不同的编程语言提供不同形式和等级的抽象支持，例如 Java 类的声明和C语言的函数原型。</p>
<p>我们已经介绍了计算机系统中使用的几个抽象，如图 1-18 所示。在处理器里，指令集架构提供了对实际处理器硬件的抽象。使用这个抽象，机器代码程序表现得就好像运行在一个一次只执行一条指令的处理器上。底层的硬件远比抽象描述的要复杂精细，它并行地执行多条指令，但又总是与那个简单有序的模型保持一致。只要执行模型一样，不同的处理器实现也能执行同样的机器代码，而又提供不同的开销和性能。</p>
<p><img src="/image/caspp/chapter1/1-17.jpg"></p>
<p>如上所示计算机系统提供的一些抽象。计算机系统中的一个重大主题就是提供不同层次的抽象表示，来隐藏实际实现的复杂性</p>
<p>在学习操作系统时，我们介绍了三个抽象：文件是对 I&#x2F;O 设备的抽象，虚拟内存是对程序存储器的抽象，而进程是对一个正在运行的程序的抽象。我们再增加一个新的抽象∶ 虚拟机，它提供对整个计算机的抽象，包括操作系统、处理器和程序。虚拟机的思想是 IBM 在 20 世纪 60 年代提出来的，但是最近才显示出其管理计算机方式上的优势，因为一些计算机必须能够运行为不同的操作系统（例如，Microsoft Windows、MacOS 和 Linux）或同一操作系统的不同版本设计的程序。</p>

  </div>
  </br>
  </br>
  
  <section id="comments" class="comments">
    <div class="valine-comment"></div>
<!--载入js，在</body>之前插入即可-->
<!--Leancloud 操作库:-->
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<!--Valine 的核心代码库-->
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
new Valine({
    el: '.valine-comment',
    app_id: 'aVoW8Ns48PCL9aWpyaraklyz-gzGzoHsz',
    app_key: '5OofdgauZeSJ0SPHIgbbQ6fe',
    placeholder: '',
    visitor: 'true',
  })
</script>
  </section>
  
</article>
    </main>
    <footer id="footer">
  Copyright &copy;
  2023
  Yu Peng
  
  
    <a class="social-links" target="_blank" rel="noopener" href="https://github.com/yuhua2000"><i class="blogfont"><img src="https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/github.svg" alt="GitHub" width="16" height="16"> </i></a>
  
    <a class="social-links" target="_blank" rel="noopener" href="https://leetcode.cn/u/yu-peng-f"><i class="blogfont"><img src="https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/leetcode.svg" alt="LeetCode" width="16" height="16"> </i></a>
  
    <a class="social-links" href="mailto:2651034096@qq.com"><i class="blogfont"><img src="https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/gmail.svg" alt="Mail" width="16" height="16"> </i></a>
  
  
</footer>
    <!-- scripts -->

<script src="/scripts/main.js"></script>

  </body>
</html>