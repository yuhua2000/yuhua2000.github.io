<!DOCTYPE html>
<html  lang=en>
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  
    
    <link rel="shortcut icon" href="/images/favicon.ico ">
    
    
    <link rel="icon" type="image/png" href="/images/favicon-android.png " sizes="192x192">
    
    
    <link rel="apple-touch-icon" href="/images/favicon-apple.png " sizes="180x180">
    
  
  <!-- title -->
  <title>Yu Peng blog 第八章 异常控制流 </title>
  <!-- styles -->
  <!-- styles -->

<link rel="stylesheet" href="/styles/global.css">

  <!-- rss -->
  
<meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <header id="header">
  
  <nav class="menu menu--right">
  
    <a class="menu__item" href="/">主页</a>
    <a class="menu__item" href="/archives/">归档</a>
    <a class="menu__item" href="/categories/">专题</a>
    <a class="menu__item" href="/tags/">标签</a>
    <a class="menu__item" href="/works/">作品</a>
    <a class="menu__item" href="/about/">关于</a>
  </nav>
</header>
    <main>
      <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post__header">
  <h1 class="post__title">第八章 异常控制流</h1>
  
  
  <div class="post__meta">
    
<time class="post__date" datetime="2024-05-31T11:44:24.000Z" itemprop="datePublished">
  
  <i class="blogfont">&#xedff;</i>
  
  2024-05-31 19:44:24
</time>

    
<div class="post__category">
  <i class="blogfont">&#xe62d;</i>
  <a class="category-link" href="/categories/csapp/">csapp</a>
</div>
  

    
<div class="post__tag">
  <i class="blogfont">&#xe7ec;</i>
  <a class="tag-link-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a>
</div>


    <div id="/2024/05/31/csapp/chapter8/chapter8/" class="leancloud_visitors post__stat" data-flag-title="第八章 异常控制流">
  <i class="blogfont">&#xe672;</i>
  <span class="leancloud-visitors-count">loading...</span>
</div>
  </div>
</header>
  <aside class="post__aside">
  <div class="post__actions">
    <a id="backTop" class="post__top" href="javascript:">
      <i class="blogfont">&#xe6b1;</i><!-- Top -->
    </a>
    <a id="share" class="post__share" href="javascript:">
      <i class="blogfont">&#xe6c1;</i>
    </a>
  </div>
  <ol class="post__toc"><li class="post__toc-item post__toc-level-1"><a class="post__toc-link" href="#%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="post__toc-text">异常控制流</span></a><ol class="post__toc-child"><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#8-1-%E5%BC%82%E5%B8%B8"><span class="post__toc-text">8.1 异常</span></a><ol class="post__toc-child"><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#8-1-1-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="post__toc-text">8.1.1 异常处理</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#8-1-2-%E5%BC%82%E5%B8%B8%E7%9A%84%E7%B1%BB%E5%88%AB"><span class="post__toc-text">8.1.2 异常的类别</span></a></li></ol></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#8-2-%E8%BF%9B%E7%A8%8B"><span class="post__toc-text">8.2 进程</span></a><ol class="post__toc-child"><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#8-2-1-%E9%80%BB%E8%BE%91%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="post__toc-text">8.2.1 逻辑控制流</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#8-2-2-%E5%B9%B6%E5%8F%91%E6%B5%81"><span class="post__toc-text">8.2.2 并发流</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#8-2-3-%E7%A7%81%E6%9C%89%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="post__toc-text">8.2.3 私有地址空间</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#8-2-4-%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%86%85%E6%A0%B8%E6%A8%A1%E5%BC%8F"><span class="post__toc-text">8.2.4 用户模式和内核模式</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#8-2-5-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="post__toc-text">8.2.5 上下文切换</span></a></li></ol></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#8-3-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="post__toc-text">8.3 系统调用错误处理</span></a></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#8-4-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="post__toc-text">8.4 进程控制</span></a><ol class="post__toc-child"><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#8-4-2-%E5%88%9B%E5%BB%BA%E5%92%8C%E7%BB%88%E6%AD%A2%E8%BF%9B%E7%A8%8B"><span class="post__toc-text">8.4.2 创建和终止进程</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#8-4-3-%E5%9B%9E%E6%94%B6%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="post__toc-text">8.4.3 回收子进程</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#8-4-4-%E8%AE%A9%E8%BF%9B%E7%A8%8B%E4%BC%91%E7%9C%A0"><span class="post__toc-text">8.4.4 让进程休眠</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#8-4-5-%E5%8A%A0%E8%BD%BD%E5%B9%B6%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="post__toc-text">8.4.5 加载并运行程序</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#8-4-6-%E5%88%A9%E7%94%A8-fork-%E5%92%8C-execve-%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="post__toc-text">8.4.6 利用 fork 和 execve 运行程序</span></a></li></ol></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#8-5-%E4%BF%A1%E5%8F%B7"><span class="post__toc-text">8.5 信号</span></a><ol class="post__toc-child"><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#8-5-1-%E4%BF%A1%E5%8F%B7%E6%9C%AF%E8%AF%AD"><span class="post__toc-text">8.5.1 信号术语</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#8-5-2-%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7"><span class="post__toc-text">8.5.2 发送信号</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#8-5-3-%E6%8E%A5%E6%94%B6%E4%BF%A1%E5%8F%B7"><span class="post__toc-text">8.5.3 接收信号</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#8-5-4-%E9%98%BB%E5%A1%9E%E5%92%8C%E8%A7%A3%E9%99%A4%E9%98%BB%E5%A1%9E%E4%BF%A1%E5%8F%B7"><span class="post__toc-text">8.5.4 阻塞和解除阻塞信号</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#8-5-5-%E7%BC%96%E5%86%99%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="post__toc-text">8.5.5 编写信号处理程序</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#8-5-6-%E5%90%8C%E6%AD%A5%E6%B5%81%E4%BB%A5%E9%81%BF%E5%85%8D%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%B9%B6%E5%8F%91%E9%94%99%E8%AF%AF"><span class="post__toc-text">8.5.6 同步流以避免讨厌的并发错误</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#8-5-7-%E6%98%BE%E5%BC%8F%E5%9C%B0%E7%AD%89%E5%BE%85%E4%BF%A1%E5%8F%B7"><span class="post__toc-text">8.5.7 显式地等待信号</span></a></li></ol></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#8-6-%E9%9D%9E%E6%9C%AC%E5%9C%B0%E8%B7%B3%E8%BD%AC"><span class="post__toc-text">8.6 非本地跳转</span></a></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#8-7-%E6%93%8D%E4%BD%9C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="post__toc-text">8.7 操作进程的工具</span></a></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#8-8-%E5%B0%8F%E7%BB%93"><span class="post__toc-text">8.8 小结</span></a></li></ol></li></ol>
</aside>
  <div class="post__content" itemprop="articleBody">
    <h1 id="异常控制流"><a href="#异常控制流" class="headerlink" title="异常控制流"></a>异常控制流</h1><p>从给处理器加电开始，直到你断电为止，程序计数器假设一个值的序列</p>
<p>a<sup>0</sup>,a<sup>1</sup> … a<sup>n-1</sup></p>
<p>其中，每个a<sup>k</sup>是某个相应的指令 h的地址。每次从 a <sup>i</sup> 到 a<sup>k</sup> 的过渡称为控制转移(control transfer)。这样的控制转移序列叫做处理器的控制流(flow of control 或 control flow)。</p>
<p>最简单的一种控制流是一个“平滑的”序列，其中每个 I<sup>k</sup> 和 I<sup>k+1</sup> 在内存中都是相邻的。这种平滑流的突变（也就是I<sup>k</sup> 与 I<sup>k+1</sup> 不相邻）通常是由诸如跳转、调用和返回这样一些熟悉的程序指令造成的。这样一些指令都是必要的机制，使得程序能够对由程序变量表示的内部程序状态中的变化做出反应。</p>
<p>但是系统也必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。比如，一个硬件定时器定期产生信号，这个事件必须得到处理。包到达网络适配器后，必须存放在内存中。程序向磁盘请求数据，然后休眠，直到被通知说数据已就绪。当子进程终止时，创造这些子进程的父进程必须得到通知。</p>
<p>现代系统通过使控制流发生突变来对这些情况做出反应。一般而言，我们把这些突变称为异常控制流(Exceptional Control. Flow，ECF )。异常控制流发生在计算机系统的各个层次。比如，在硬件层 硬件检测到的事件会触发控制突然转移到异常处理程序。在操作系统层，内核通过上下文切换将控制从一个用户进程转移到另一个用户进程.在应用层，一个进程可以发送信号到另一个进程，而接收者会将控制突然转移到它的一个信号处理程序。一个程序可以通过回避通常的栈规则，并执行到其他函数中任意位置的非本地跳转来对错误做出反应。</p>
<p>作为程序员，理解 ECF 很重要，这有很多原因：</p>
<ul>
<li>理解 ECF 将帮助你理 解重要的系统概念 </li>
<li>理解 ECF 将帮助你理解应用程序是如何与操作系统交互的 </li>
<li>理解 ECF 将帮助你编写有趣的新应用程序 </li>
<li>理解 ECF 将帮助你理解并发 </li>
<li>理解 ECF 将帮助你理解软件异常如何工作</li>
</ul>
<p>对系统的学习，到目前为止你已经了解了应用是如何与硬件交互的。本章的重要性在于你将开始学习应用是如何与操作系统交互的。有趣的是，这些交互都是围绕着 ECF 的。我们将描述存在于一个计算机系统中所有层次上的各种形式的 ECF. 从异常开始，异常位于硬件和操作系统交界的部分。我们还会讨论系统调用，它们是为应用程序提供到操作系统的人口点的异常。然后，我们会提升抽象的层次，描述进程和信号，它们位于应用和操作系统的交界之处。最后讨论非本地跳转，这是 ECF 的一种应用层形式。</p>
<h2 id="8-1-异常"><a href="#8-1-异常" class="headerlink" title="8.1 异常"></a>8.1 异常</h2><p>异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。因为它们有一部分是由硬件实现的，所以具体细节将随系统的不同而有所不同。然而，对于每个系统而言，基本的思想都是相同的。在这一节中我们的目的是让你对异常和异常处理有一个一般性的了解，并且向你揭示现代计算机系统的一个经常令人感到迷惑的方面。</p>
<p>异常(exception)就是控制流中的突变，用来响应处理器状态中的某些变化。图 8-1 展示了基本的思想。</p>
<p><img src="/images/caspp/chapter8/8-1.jpg"><br>图 8-1 异常的剖析。处理器状态中的变化（事件）触发从应用程序到异常处理程序的突发的控制转（异常）。 在异常处理程序完成处理后，它将控制返回给被中断的程序或者终止</p>
<p>在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做异常表(exception table)的跳转表，进行一个间接过程调用（异常）， 到一个专门设计用来处理这类事件的操作系统子程序(异常处理程序(exception handler))。 当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下 3 种情况中的一种：</p>
<ol>
<li>处理程序将控制返回给当前指令 即当事件发生时正在执行的指令。</li>
<li>处理程序将控制返回给込x，，如果没有发生异常将会执行的下一条指令。</li>
<li>处理程序终止被中断的程序。</li>
</ol>
<h3 id="8-1-1-异常处理"><a href="#8-1-1-异常处理" class="headerlink" title="8.1.1 异常处理"></a>8.1.1 异常处理</h3><p>异常可能会难以理解，因为处理异常需要硬件和软件紧密合作。很容易搞混哪个部分执行哪个任务。让我们更详细地来看看硬件和软件的分工吧。</p>
<p>系统中可能的每种类型的异常都分配了一个唯一的非负整数的异常号(exception number)。 其中一些号码是由处理器的设计者分配的，其他号码是由操作系统内核（操作系统常驻内存的部分）的设计者分配的。前者的示例包括被零除、缺页、内存访问违例、断点以及算术运算溢出。后者的示例包括系统调用和来自外部 I&#x2F;O 设备的信号。</p>
<p>在系统启动时（当计算机重启或者加电时），操作系统分配和初始化一张称为异常表的跳转表，使得表目 k 包含异常 k 的处理程序的地址。图 8-2 展示了异常表的格式。</p>
<p><img src="/images/caspp/chapter8/8-2.jpg"><br>图 8-2 异常表。异常表是一张跳转表，其中表目k包含异常 k 的处理程序代码的地址</p>
<p>在运行时（当系统在执行某个程序时）， 处理器检测到发生了一个事件，并且确定了相应的异常号k，随后，处理器触发异常，方法是执行间接过程调用，通过异常表的表目 h 转到相应的处理程序。图 8-3 展示了处理器如何使用异常表来形成适当的异常处理程序的地址。异常号是到异常表中的索引，异常表的起始地址放在一个叫做异常表基址寄存器(exception table base register)的特殊 CPU 寄存器里。</p>
<p><img src="/images/caspp/chapter8/8-3.jpg"><br>图 8-3 生成异常处理程序的地址。异常号是到异常表中的索引</p>
<p>异常类似于过程调用，但是有一些重要的不同之处：</p>
<ul>
<li>过程调用时，在跳转到处理程序之前，处理器将返回地址压入栈中。然而，根据异常的类型，返回地址要么是当前指令（当事件发生时正在执行的指令）， 要么是下一条指令（如果事件不发生，将会在当前指令后执行的指令）</li>
<li>处理器也把一些额外的处理器状态压到栈里，在处理程序返回时，重新开始执行被中断的程序会需要这些状态。</li>
<li>如果控制从用户程序转移到内核，所有这些项目都被压到内核栈中，而不是压到用户栈中。</li>
<li>异常处理程序运行在内核模式下， 这意味着它们对所有的系统资源都有完全的访问权限。</li>
</ul>
<p>一旦硬件触发了异常，剩下的工作就是由异常处理程序在软件中完成。在处理程序处理完事件之后，它通过执行一条特殊的“从中断返回”指令，可选地返回到被中断的程序，该指令将适当的状态弹回到处理器的控制和数据寄存器中，如果异常中断的是一个用户程序，就将状态恢复为用 户模式（见 8.2.4 节）， 然后将控制返回给被中断的程序。</p>
<h3 id="8-1-2-异常的类别"><a href="#8-1-2-异常的类别" class="headerlink" title="8.1.2 异常的类别"></a>8.1.2 异常的类别</h3><p>异常可以分为四类：中断(interrupt)、陷牌(trap)、故障(fault)和终止(abort)。表 8-4 中的表对这些类别的属性做了小结。</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>原因</th>
<th>异步 &#x2F; 同步</th>
<th>返回行为</th>
</tr>
</thead>
<tbody><tr>
<td>中断</td>
<td>来自</td>
<td>I&#x2F;O 设备的信号</td>
<td>异步</td>
</tr>
<tr>
<td>陷阱</td>
<td>有意的异常</td>
<td>同步</td>
<td>总是返回到下一条指令</td>
</tr>
<tr>
<td>故障</td>
<td>潜在可恢复的错误</td>
<td>同步</td>
<td>可能返回到当前指令</td>
</tr>
<tr>
<td>终止</td>
<td>不可恢复的错误</td>
<td>同步</td>
<td>不会返回</td>
</tr>
</tbody></table>
<p>表 8-4 异常的类别。异步异常是由处理器外部的 I&#x2F;O 设备中的事件产生的。同步异常是执行一条指令的直接产物</p>
<h2 id="8-2-进程"><a href="#8-2-进程" class="headerlink" title="8.2 进程"></a>8.2 进程</h2><p>异常是允许操作系统内核提供进程(process)概念的基本构造块，进程是计算机科学中最深刻、最成功的概念之一。</p>
<p>在现代系统上运行一个程序时，我们会得到一个假象，就好像我们的程序是系统中当前运行的唯一的程序一样。我们的程序好像是独占地使用处理器和内存。处理器就好像是无间断地一条接一条地执行我们程序中的指令。最后，我们程序中的代码和数据好像是系统内存中唯一的对象。这些假象都是通过进程的概念提供给我们的。 </p>
<p>进程的经典定义就是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文(context)中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。</p>
<p>每次用户通过向 shell 输人一个可执行目标文件的名字，运行程序时，shell 就会创建一个新的进程，然后在这个新进程的上下文中运行这个可执行目标文件。应用程序也能够创建新进程，并且在这个新进程的上下文中运行它们自己的代码或其他应用程序。关于操作系统如何实现进程的细节的讨论超出了本书的范围。反之，我们将关注进程提供给应用程序的关键抽象：</p>
<p>一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器。个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统。让我们更深人地看看这些抽象。</p>
<h3 id="8-2-1-逻辑控制流"><a href="#8-2-1-逻辑控制流" class="headerlink" title="8.2.1 逻辑控制流"></a>8.2.1 逻辑控制流</h3><p>即使在系统中通常有许多其他程序在运行，进程也可以向每个程序提供一种假象，好像它在独占地使用处理器。如果想用调试器单步执行程序，我们会看到一系列的程序计数器(PC)的值，这些值唯一地对应于包含在程序的可执行目标文件中的指令，或是包含在运行时动态链接到程序的共享对象中的指令。这个 PC 值的序列叫做逻辑控制流，或者简称逻辑流。</p>
<p><img src="/images/caspp/chapter8/8-12.jpg"><br>图 8-12 逻辑控制流。进程为每个程序提供了一种假象,好像程序在独占地使用处理器。每个竖直的条表示一个进程的逻辑控制流的一部分</p>
<p>图 8-12 的关键点在于进程是轮流使用处理器的。每个进程执行它的流的一部分，然后被抢占(preempted)(暂时挂起)， 然后轮到其他进程。对于一个运行在这些进程之一的上下文中的程序，它看上去就像是在独占地使用处理器。唯一的反面例证是，如果我们精确地测量每条指令使用的时间，会发现在程序中一些指令的执行之间, CPU 好像会周期性地停顿。然而，每次处理器停顿，它随后会继续执行我们的程序，并不改变程序内存位置或寄存器的内容。</p>
<h3 id="8-2-2-并发流"><a href="#8-2-2-并发流" class="headerlink" title="8.2.2 并发流"></a>8.2.2 并发流</h3><p>计算机系统中逻辑流有许多不同的形式。异常处理程序、进程、信号处理程序、线程和 Java 进程都是逻辑流的例子。</p>
<p>一个逻辑流的执行在时间上与另一个流重叠，称为并发流(concurrent flow), 这两个流被称为并发地运行。更准确地说，流 X 和 Y 互相并发，当且仅当 X 在 Y 开始之后和 Y结束之前开始，或者 Y 在 X 开始之后和 X 结束之前开始。例如，图 8-12 中，进程 A 和 B并发地运行，A 和 C 也一样。另一方面，B 和 C 没有并发地运行，因为 B 的最后一条指令在 C 的第一条指令之前执行。</p>
<p>多个流并发地执行的一般现象被称为并发(concurrency)。一个进程和其他进程轮流运行的概念称为多任务(multitasking)。一个进程执行它的控制流的一部分的每一时间段叫做时间片(time S.lics)。 因此，多任务也叫做时间分片(time slicing)。 例如，图 8-12 中，进程 A 的流由两个时间片组成。</p>
<p>注意，并发流的思想与流运行的处理器核数或者计算机数无关。如果两个流在时间上重叠，那么它们就是并发的，即使它们是运行在同一个处理器上。不过，有时我们会发现确认并行流是很有帮助的，它是并发流的一个真子集。如果两个流并发地运行在不同的处理器核或者计算机上，那么我们称它们为并行流(parallel flow), 它们并行地运行(running in parallel)且并行地执行(parallel execution)。</p>
<h3 id="8-2-3-私有地址空间"><a href="#8-2-3-私有地址空间" class="headerlink" title="8.2.3 私有地址空间"></a>8.2.3 私有地址空间</h3><p>进程也为每个程序提供一种假象，好像它独占地使用系统地址空间。在一台 n 位地址的机器上，地址空间是 2<sup>n</sup> 个可能地址的集合,0,1, ···, 2<sup>n</sup>-1。进程为每个程序提供它自己的私有地址空间。一般而言，和这个空间中某个地址相关联的那个内存字节是不能被其他进程读或者写的，从这个意义上说，这个地址空间是私有的。</p>
<p>尽管和每个私有地址空间相关联的内存的内容一般是不同的，但是每个这样的空间都有相同的通用结构。比如，图 8-13 展示了一个 x86-64 Linux 进程的地址空间的组织结构。</p>
<p>地址空间底部是保留给用户程序的，包括通常的代码、数据、堆和栈段。代码段总是从地址 0x400000 开始。地址空间顶部保留给内核（操作系统常驻内存的部分）。 地址空间的这个部分包含内核在代表进程执行指令时（比如当应用程序执行系统调用时）使用的代码、数据和栈。</p>
<p><img src="/images/caspp/chapter8/8-13.jpg"><br>图 8-13 进程地址空间</p>
<h3 id="8-2-4-用户模式和内核模式"><a href="#8-2-4-用户模式和内核模式" class="headerlink" title="8.2.4 用户模式和内核模式"></a>8.2.4 用户模式和内核模式</h3><p>为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制<br>一个应用可以执行的指令以及它可以访问的地址空间范围。</p>
<p>处理器通常是用某个控制寄存器中的一个模式位(mode bit)来提供这种功能的，该寄存器描述了进程当前享有的特权。当设置了模式位时，进程就运行在内核模式中（有时叫做超级用 户模式）。 一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。</p>
<p>没有设置模式位时，进程就运行在用户模式中。用户模式中的进程不允许执行特权指令(privileged instruction), 比如停止处理器、改变模式位，或者发起一个 I&#x2F;O 操作。也不允许用户模式中的进程直接引用地址空间中内核区内的代码和数据。任何这样的尝试都会导致致命的保护故障。反之，用户程序必须通过系统调用接口间接地访问内核代码和数据。</p>
<p>运行应用程序代码的进程初始时是在用户模式中的。进程从用户模式变为内核模式的唯一方法是通过诸如中断、故障或者陷人系统调用这样的异常。当异常发生时，控制传递到异常处理程序，处理器将模式从用户模式变为内核模式。处理程序运行在内核模式中，当它返回到应用程序代码时，处理器就把模式从内核模式改回到用户模式。</p>
<p>Linux 提供了一种聪明的机制，叫做&#x2F;Proc 文件系统，它允许用户模式进程访问内核数据结构的内容。&#x2F;proc 文件系统将许多内核数据结构的内容输出为一个用户程序可以读的文</p>
<p>本文件的层次结构。比如，你可以使用&#x2F;proc 文件系统找出一般的系统属性，比如 CPU 类型(&#x2F;proc&#x2F;cpuinfo)。或者某个特殊的进程使用的内存段(&#x2F;proc&#x2F;<process-id> &#x2F;maps)。2.6版本的 Linux 内核引人 &#x2F;sys 文件系统，它输出关于系统总线和设备的额外的低层信息。</p>
<h3 id="8-2-5-上下文切换"><a href="#8-2-5-上下文切换" class="headerlink" title="8.2.5 上下文切换"></a>8.2.5 上下文切换</h3><p>操作系统内核使用一种称为上下文切换(context switch)的较高层形式的异常控制流来实现多任务。上下文切换机制是建立在 8.1 节中已经讨论过的那些较低层异常机制之上的。内核为每个进程维持一个上下文(context)。上下文就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描述地址空间的页表、包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫做调度(scheduling), 是由内核中称为调度器(scheduler)的代码处理的。当内核选择一个新的进程运行时，我们说内核调度了这个进程。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程，上下文切换 1)保存当前进程的上下文，2)恢复某个先前被抢占的进程被保存的上下文，3)将控制传递给这个新恢复的进程。</p>
<p>当内核代表用户执行系统调用时，可能会发生上下文切换。如果系统调用因为等待某个事件发生而阻塞，那么内核可以让当前进程休眠，切换到另一个进程。比如，如果一个read 系统调用需要访问磁盘，内核可以选择执行上下文切换，运行另外一个进程，而不是等待数据从磁盘到达。另一个示例是 sleep 系统调用，它显式地请求让调用进程休眠。一般而言，即使系统调用没有阻塞，内核也可以决定执行上下文切换，而不是将控制返回给调用进程。</p>
<p>中断也可能引发上下文切换。比如，所有的系统都有某种产生周期性定时器中断的机制，通常为每 1 毫秒或每 10 毫秒。每次发生定时器中断时，内核就能判定当前进程已经运行了足够长的时间，并切换到一个新的进程。</p>
<p>图 8-14 展示了一对进程 A 和 B 之间上下文切换的示例。<br><img src="/images/caspp/chapter8/8-14.jpg"><br>图 8-14 进程上下文切换的剖析</p>
<h2 id="8-3-系统调用错误处理"><a href="#8-3-系统调用错误处理" class="headerlink" title="8.3 系统调用错误处理"></a>8.3 系统调用错误处理</h2><p>当 Unix 系统级函数遇到错误时，它们通常会返回一1，并设置全局整数变量来表示什么出错了。程序员应该总是检査错误，但是不幸的是，许多人都忽略了错误检查，因为它使代码变得臃肿，而且难以读懂。比如，下面是我们调用 Unix fork 函数时会如何检查错误：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork error: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>strerror 函数返回一个文本串，描述了和某个 errno 值相关联的错误。通过定义下<br>面的错误报告函数，我们能够在某种程度上简化这个代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">unix_error</span><span class="params">(<span class="type">char</span>* msg)</span> <span class="comment">/* unix-style error */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s: %s\n&quot;</span>, msg, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给定这个函数，我们对 fork 的调用从 4 行缩减到 2 行:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">    unix_error(<span class="string">&quot;fork error&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>通过使用错误处理包装函数，我们可以更进一步地简化代码，Stevens 在[110]中首先提出了这种方法。对于一个给定的基本函数 foo, 我们定义一个具有相同参数的包装函数Foo,但是第一个字母大写了。包装函数调用基本函数，检查错误，如果有任何问题就终止。比如，下面是 fork 函数的错误处理包装函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">Fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;Fork error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给定这个包装函数，我们对 fork 的调用就缩减为 1 行:</p>
<blockquote>
<p>pid &#x3D; Fork();</p>
</blockquote>
<h2 id="8-4-进程控制"><a href="#8-4-进程控制" class="headerlink" title="8.4 进程控制"></a>8.4 进程控制</h2><p>Unix 提供了大量从 C 程序中操作进程的系统调用。这一节将描述这些重要的函数，并举例说明如何使用它们。</p>
<p>8.4.1 获取进程 ID</p>
<p>每个进程都有一个唯一的正数(非零)进程 ID(PID)。getpid 函数返回调用进程的 PID。getppid函数返回它的父进程的 PID(创建调用进程的进程)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 返回：调用者或其父进程的 PID</span></span><br></pre></td></tr></table></figure>

<p>getpid 和 getppid 函数返回一个类型为 pid_t 的整数值，在 Linux 系统上它在types.h 中被定义为 int。</p>
<h3 id="8-4-2-创建和终止进程"><a href="#8-4-2-创建和终止进程" class="headerlink" title="8.4.2 创建和终止进程"></a>8.4.2 创建和终止进程</h3><p>从程序员的角度，我们可以认为进程总是处于下面三种状态之一：</p>
<ul>
<li>运行。进程要么在 CPU 上执行，要么在等待被执行且最终会被内核调度。</li>
<li>停止。进程的执行被挂起(suspended), 且不会被调度。当收到 SIGSTOP、SIGTSTP、SIGTTIN 或者 SIGTTOU 信号时，进程就停止，并且保持停止直到它收到一个 SIGCONT 信号，在这个时刻，进程再次开始运行。</li>
<li>终止。进程永远地停止了。进程会因为三种原因终止：1)收到一个信号，该信号的默认行为是终止进程，2)从主程序返回，3)调用 exit 函数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br><span class="line"><span class="comment">// 该函数不返回。</span></span><br></pre></td></tr></table></figure>

<p>exit 函数以 status 退出状态来终止进程（另一种设置退出状态的方法是从主程序中返回一个整数值）。父进程通过调用 fork 函数创建一个新的运行的子进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 返回：子进程返回 0，父进程返回子进程的 PID, 如果出错，则为 一1。</span></span><br></pre></td></tr></table></figure>

<p>新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的(但是独立的)一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用 fork 时，子进程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同的 PID。</p>
<p>fork 函数是有趣的（也常常令人迷惑）， 因为它只被调用一次，却会返回两次：一次是在调用进程（父进程）中，一次是在新创建的子进程中。在父进程中，fork 返回子进程的 PID。在子进程中，fork 返回 0。因为子进程的 PID 总是为非零，返回值就提供一个明确的方法来分辨程序是在父进程还是在子进程中执行。</p>
<h3 id="8-4-3-回收子进程"><a href="#8-4-3-回收子进程" class="headerlink" title="8.4.3 回收子进程"></a>8.4.3 回收子进程</h3><p>当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程回收(reaped)。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程，从此时开始,该进程就不存在了。一个终止了但还未被回收的进程称为僵死进程(zombie)。</p>
<p>如果一个父进程终止了，内核会安排 init 进程成为它的孤儿进程的养父。 进程的 PID 为 1，是在系统启动时由内核创建的，它不会终止，是所有进程的祖先。如果父进程没有回收它的僵死子进程就终止了，那么内核会安排 init 进程去回收它们。不过，长时间运行的程序，比如 shell 或者服务器，总是应该回收它们的僵死子进程。即使僵死子进程没有运行，它们仍然消耗系统的内存资源。</p>
<p>一个进程可以通过调用 waitpid 函数来等待它的子进程终止或者停止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *statusp, <span class="type">int</span> options)</span>;</span><br><span class="line"><span class="comment">// 返回：如果成功，则为子进程的 PID, 如果 WNOHANG,则为 0，如果其他错误，则为 一1。</span></span><br></pre></td></tr></table></figure>

<p>waitpid 函数有点复杂。默认情况下（当 options&#x3D;0 时）， waitpid 挂起调用进程的执行，直到它的等待集合(wait set)中的一个子进程终止。如果等待集合中的一个进程在刚调用的时刻就已经终止了，那么 waitpid 就立即返回。在这两种情况中，waitpid 返回导致 waitpid 返回的已终止子进程的 PID。此时，已终止的子进程已经被回收，内核会从系统中删除掉它的所有痕迹。</p>
<p><strong>1. 判定等待集合的成员</strong></p>
<ul>
<li>如果 Pid&gt;0, 那么等待集合就是一个单独的子进程，它的进程 ID 等于 pid。</li>
<li>如果 Pid&#x3D;-1，那么等待集合就是由父进程所有的子进程组成的。</li>
</ul>
<p><strong>2. 修改默认行为</strong><br>可以通过将 options 设置为常量 WNOHANG、WUNTRACED 和 WCONTINUED的各种组合来修改默认行为。</p>
<p><strong>3. 检查已回收子进程的退出状态</strong><br>如果 statusp 参数是空，那么 waitpid 就会在 status 中放上关于导致返回的子进程的状态信息，status 是 statusp 指向的值。wait.h 头文件定文了解释 status 参数的几个宏：</p>
<p><strong>5. wait 函数</strong><br>wait 函数是 waitpid 函数的简单版本:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *statusp)</span>;</span><br><span class="line"><span class="comment">// 返回：如果成功，则为子进程的 PID, 如果出错，则为 一1。</span></span><br></pre></td></tr></table></figure>

<p>调用 wait(&amp;status)等价于调用 waitpid(- l,&amp;status,0)。</p>
<h3 id="8-4-4-让进程休眠"><a href="#8-4-4-让进程休眠" class="headerlink" title="8.4.4 让进程休眠"></a>8.4.4 让进程休眠</h3><p>sleep 函数将一个进程挂起一段指定的时间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span>;</span><br><span class="line"><span class="comment">// 返回：还要休眠的秒数。</span></span><br></pre></td></tr></table></figure>
<p>如果请求的时间量已经到了，sleep 返回 0, 否则返回还剩下的要休眠的秒数。后一种情况是可能的，如果因为 sleep 函数被一个信号中断而过早地返回。我们将在 8.5 节中详细讨论信号。</p>
<p>我们会发现另一个很有用的函数是 pause 函数，该函数让调用函数休眠，直到该进程收到一个信号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pause</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 总是返回一1。</span></span><br></pre></td></tr></table></figure>

<h3 id="8-4-5-加载并运行程序"><a href="#8-4-5-加载并运行程序" class="headerlink" title="8.4.5 加载并运行程序"></a>8.4.5 加载并运行程序</h3><p>execve 函数在当前进程的上下文中加载并运行一个新程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *argv[],</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> *envp[])</span>;</span><br><span class="line"><span class="comment">// 如果成功，则不返回，如果错误，则返回一1。</span></span><br></pre></td></tr></table></figure>

<p>execve 函数加载并运行可执行目标文件 filename, 且带参数列表 argv 和环境变量列表 envp。只有当出现错误时，例如找不到 filename,execve 才会返回到调用程序。所以，与 fork —次调用返回两次不同，execve 调用一次并从不返回。</p>
<p>在execve加载了 filename 之后，它调用 7.9 节中描述的启动代码。启动代码设置栈，并将控制传递给新程序的主函数，该主函数有如下形式的原型</p>
<blockquote>
<p>int main(int argc, char **argv, char **envp);</p>
</blockquote>
<p>或者等价的</p>
<blockquote>
<p>int main(int argc, char *argv[], char *envp[]);  </p>
</blockquote>
<p>当 main 开始执行时，用户栈的组织结构如图 8-22 所示。</p>
<p><img src="/images/caspp/chapter8/8-22.jpg"><br>图 8-22 —个新程序开始时，用户栈的典型组织结构</p>
<p>main 函数有 3 个参数：1）它给出 argv[ ]数组中非空指针的数量，2）argv,指向 argv[]数组中的第一个条目，3）envp 指向 envp[]数组中的第一个条目。</p>
<p>Linux 提供了几个函数来操作环境数组 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="comment">// 返回：若存在则 为指向 name 的指针，若无匹配的，则为 NULL</span></span><br></pre></td></tr></table></figure>
<p>getenv 函数在环境数组中搜索字符串 “name&#x3D;value” 如果找到了，它就返回一个指向 value 的指针，否则它就返回 NULL.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *newvalue, <span class="type">int</span> overwrite)</span>;</span><br><span class="line"><span class="comment">// 返回：若成功则为 0，若错误则为一1。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unsetenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>


<p>如果环境数组包含一个形如 “name&#x3D;value” 的字符串，那么 unsetenv 会删除它，而 setenv 会用 newvalue 代替 oldvalue但是只有在 overwirte 非零时才会这样。如果 name 不存在，那么 setenv 就把 “name&#x3D;newvalue”添加到数组中</p>
<h3 id="8-4-6-利用-fork-和-execve-运行程序"><a href="#8-4-6-利用-fork-和-execve-运行程序" class="headerlink" title="8.4.6 利用 fork 和 execve 运行程序"></a>8.4.6 利用 fork 和 execve 运行程序</h3><p>像 Unix shell 和 Web 服务器这样的程序大量使用了 fork 和个交互型的应用级程序，它代表用户运行其他程序。最早的 shell 是 sh 程序，后面出现了一些变种，比如 csh,tcsh,ksh 和 bash,shell 执行一系列的读&#x2F;求值(read&#x2F;evaluate)步骤，然后终止。读步骤读取来自用户的一个命令行。求值步骤解析命令行，并代表用户运行程序。</p>
<h2 id="8-5-信号"><a href="#8-5-信号" class="headerlink" title="8.5 信号"></a>8.5 信号</h2><p>到目前为止对异常控制流的学习中，我们已经看到了硬件和软件是如何合作以提供基本的低层异常机制的。我们也看到了操作系统如何利用异常来支持进程上下文切换的异常控制流形式。在本节中，我们将研究一种更髙层的软件形式的异常，称为 Linux 信号，它允许进程和内核中断其他进程。</p>
<p>一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。比如，图 8-26展示了 Linux 系统上支持的 30 种不同类型的信号。</p>
<p><img src="/images/caspp/chapter8/8-26.jpg"><br>图 8-26 Linux 信号</p>
<h3 id="8-5-1-信号术语"><a href="#8-5-1-信号术语" class="headerlink" title="8.5.1 信号术语"></a>8.5.1 信号术语</h3><p>传送一个信号到目的进程是由两个不同步骤组成的：</p>
<ul>
<li>发送信号</li>
<li>接收信号</li>
</ul>
<p>一个发出而没有被接收的信号叫做待处理信号(pending signal)。 在任何时刻，一种类型至多只会有一个待处理信号。如果一个进程有一个类型为 k 的待处理信号，那么任何接下来发送到这个进程的类型为々的信号都不会排队等待；它们只是被简单地丢弃。一个进程可以有选择性地阻塞接收某种信号。当一种信号被阻塞时，它仍可以被发送，但是产生的待处理信号不会被接收，直到进程取消对这种信号的阻塞。</p>
<p>一个待处理信号最多只能被接收一次。内核为每个进程在 pending 位向量中维护着待处理信号的集合，而在 blocked 位向量e中维护着被阻塞的信号集合。只要传送了一个类型为 k 的信号，内核就会设置 pending 中的第 k 位 ，而只要接收了一个类型为 k 的信号，内核就会清除 penaing 中的第 k 位。</p>
<h3 id="8-5-2-发送信号"><a href="#8-5-2-发送信号" class="headerlink" title="8.5.2 发送信号"></a>8.5.2 发送信号</h3><p>Unix 系统提供了大量向进程发送信号的机制。所有这些机制都是基于进程组(process group)这个概念的。</p>
<p><strong>1. 进程组</strong><br>每个进程都只属于一个进程组，进程组是由一个正整数进程组 ID 来标识的。getpgrp 函数返回当前进程的进程组 ID:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 返回：调用进程的进程组 IDB</span></span><br></pre></td></tr></table></figure>

<p>默认地，一个子进程和它的父进程同属于一个进程组。一个进程可以通过使用setpgid 函数来改变自己或者其他进程的进程组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;</span><br><span class="line"><span class="comment">// 返回：若成功则为 0， 若错误则为 -1。</span></span><br></pre></td></tr></table></figure>

<p>setpgid 函数将进程 pid 的进程组改为 pgid。如果 pid 是 0, 那么就使用当前进程的 PID 如果 pgid 不是 0, 那么就用 pid 指定的进程的 HD 作为进程组 ID。</p>
<p><strong>2. 用&#x2F;bin&#x2F;kill 程序发送信号</strong></p>
<p>&#x2F;bin&#x2F;kill 程序可以向另外的进程发送任意的信号。比如，命令</p>
<blockquote>
<p>linux&gt; &#x2F;bin&#x2F;kill -9 15213</p>
</blockquote>
<p>发送信号 9(SIGKILL)给进程 15213。一个为负的 PID 会导致信号被发送到进程组 PID 中的每个进程。比如，命令</p>
<blockquote>
<p>linux&gt; &#x2F;bin&#x2F;kill -9 -15213</p>
</blockquote>
<p>发送一个 SIGKILL 信号给进程组 15213 中的每个进程。注意，在此我们使用完整路径&#x2F;bin&#x2F;kill 因为有些 Unix shell 有自己内置的 kill 命令。</p>
<p><strong>3. 从键盘发送信号</strong></p>
<p>Unix shell 使用作业(job)这个抽象概念来表示为对一条命令行求值而创建的进程。在任何时刻，至多只有一个前台作业和 0 个或多个后台作业。比如，键入</p>
<blockquote>
<p>linux&gt; ls | sort</p>
</blockquote>
<p>会创建一个由两个进程组成的前台作业，这两个进程是通过 Unix 管道连接起来的：一个进程运行 ls ,程序，另一个运行 sort 程序。shell 为每个作业创建一个独立的进程组。进程组 ID 通常取自作业中父进程中的一个。</p>
<p>在键盘上输入 Ctd+C 会导致内核发送一个 SIGINT 信号到前台进程组中的每个进程。默认情况下，结果是终止前台作业。类似地，输入 Ctrl+Z 会发送一个 SIGTSTP 信号到前台进程组中的每个进程。默认情况下，结果是停止(挂起)前台作业。</p>
<p><strong>4. 用 kill 函数发送信号</strong></p>
<p>进程通过调用 kill 函数发送信号给其他进程（包括它们自己）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="comment">// 返回：若成功则为 0, 若错误则为 一1。</span></span><br></pre></td></tr></table></figure>

<p>如果 pid 大于零，那么 kill 函数发送信号号码 sig 给进程 pid, 如果 pid 等于零，那么kill 发送信号 sig 给调用进程所在进程组中的每个进程，包括调用进程自己。如果 pid小于零，kill 发送信号 sig 给进程组 |pid|（pid 的绝对值）中的每个进程。</p>
<p><strong>5. 用 alarm 函数发送信号</strong></p>
<p>进程可以通过调用 alarm 函数向它自己发送 SIGALRM 信号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span>;</span><br><span class="line"><span class="comment">// 返回：前一次闹钟剩余的秒数，若以前没有设定闹钟，则为 0。</span></span><br></pre></td></tr></table></figure>

<p>alarm 函数安排内核在 secs秒后发送一个 SIGALRM 信号给调用进程。如果secs是零，那么不会调度安排新的闹钟(alarm)。在任何情况下，对 alarm 的调用都将取消任何待处理的(pending)闹钟，并且返回任何待处理的闹钟在被发送前还剩下的秒数（如果这次对 alarm 的调用没有取消它的话 如果没有任何待处理的闹钟，就返回零。</p>
<h3 id="8-5-3-接收信号"><a href="#8-5-3-接收信号" class="headerlink" title="8.5.3 接收信号"></a>8.5.3 接收信号</h3><p>当内核把进程 P 从内核模式切换到用户模式时（例如，从系统调用返回或是完成了一<br>次上下文切换）， 它会检査进程 的未被阻塞的待处理信号的集合(pending &amp;~blocked)。如果这个集合为空（通常情况下）， 那么内核将控制传递到 P 的逻辑控制流中的下一条指令，然而，如果集合是非空的，那么内核选择集合中的某个信号 k（通常是最小的k），并且强制 P 接收信号 k 收到这个信号会触发进程采取某种行为。一旦进程完成了这个行为，那么控制就传递回 p 的逻辑控制流中的下一条指令。每个信号类型都有一个预定义的默认行为 ，是下面中的一种：</p>
<ul>
<li>进程终止。</li>
<li>进程终止并转储内存。</li>
<li>进程停止(挂起)直到被 SIGCONT 信号重启。</li>
<li>进程忽略该信号。</li>
</ul>
<p>图 8-26 展示了与每个信号类型相关联的默认行为。比如，收到 SIGKILL 的默认行为就是终止接收进程。另外，接收到 SIGCHLD 的默认行为就是忽略这个信号。进程可以通过使用 signal 函数修改和信号相关联的默认行为。唯一的例外是 SIGSTOP 和 SIGKILL。它们的默认行为是不能修改的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br><span class="line"><span class="comment">// 返回：若成功则 为指向前次处理程序的指针，若出错则为 SKLERR(不设置 e线aoh.</span></span><br></pre></td></tr></table></figure>

<p>signal 函数可以通过下列三种方法之一来改变和信号 Signum 相关联的行为：</p>
<ul>
<li>如果 handler 是 SIG_IGN。那么忽略类型为 signum 的信号。</li>
<li>如果 handler 是 SIG_DFL。那么类型为 signum 的信号行为恢复为默认行为。</li>
<li>否则，handler 就是用户定义的函数的地址，这个函数被称为信号处理程序，只要进程接收到一个类型为 signum 的信号，就会调用这个程序。通过把处理程序的地址传递到 signal 函数从而改变默认行为，这叫做设置信号处理程序（installing the handler)。 调用信号处理程序被称为捕获信号。执行信号处理程序被称为处理信号。</li>
</ul>
<p>当一个进程捕获了一个类型为k的信号时，会调用为信号k设置的处理程序，一个整数参数被设置为k。这个参数允许同一个处理函数捕获不同类型的信号。</p>
<p>当处理程序执行它的 return 语句时，控制（通常）传递回控制流中进程被信号接收中断位置处的指令。我们说“通常”是因为在某些系统中，被中断的系统调用会立即返回一个错误。</p>
<p>图 8-30 展示了一个程序，它捕获用户在键盘上输人 Ctrl+C 时发送的 SIGINT 信号。SIGINT 的默认行为是立即终止该进程。在这个示例中，我们将默认行为修改为捕获信号，输出一条消息，然后终止该进程。</p>
<p><img src="/images/caspp/chapter8/8-30.jpg"><br>图 8-30 一个用信号处理程序捕获 SIGINT 信号的程序</p>
<p>信号处理程序可以被其他信号处理程序中断，如图 8-31 所示。在这个例子中，主程序捕获到信号s该信号会中断主程序，将控制转移到处理程序 S。S 在运行时，程序捕获信号 t!&#x3D;s 该信号会中断 S 控制转移到处理程序T了。 当T返回时，S 从它被中断的地方继续执行。最后，S 返回，控制传送回主程序，主程序从它被中断的地方继续执行。</p>
<p><img src="/images/caspp/chapter8/8-31.jpg"><br>图-31 信号处理程序可以被其他信号处理程序中断</p>
<h3 id="8-5-4-阻塞和解除阻塞信号"><a href="#8-5-4-阻塞和解除阻塞信号" class="headerlink" title="8.5.4 阻塞和解除阻塞信号"></a>8.5.4 阻塞和解除阻塞信号</h3><p>Linux 提供阻塞信号的隐式和显式的机制：</p>
<p>隐式阻塞机制。内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。例如，图 8-31 中，假设程序捕获了信号 当前正在运行处理程序 S。如果发送给该进程另一个信号 5, 那么直到处理程序 S 返回，s 会变成待处理而没有被接收。<br>显式阻塞机制。应用程序可以使用 sigprocmask 函数和它的辅助函数，明确地阻塞和解除阻塞选定的信号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, sigsetÿt *oldset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">// 返回：如果成功则为 0，若出错则为一1。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">// 返回：若 signum 是 set 的成员则为 1，如果不是则为 0，若出错则为 一1。</span></span><br></pre></td></tr></table></figure>

<p>sigprocmask 函数改变当前阻塞的信号集合（8.5.1节中描述的blocked位向量）。具体的行为依赖于 how 的值：</p>
<p>SIG_BLOCK: 把 set 中的信号添加到 blocked 中(blocked&#x3D;blocked|set)。<br>SIG_UNBLOCK: 从 blocked 中删除 set 中的信号(blocked&#x3D;blocked &amp; set)。<br>SIG一SETMASK: block&#x3D;set。</p>
<p>如果 oldset 非空，那么 blocked 位向量之前的值保存在 oldset 中。</p>
<p>使用下述函数对 set 信号集合进行操作：sigeirptyset 初始化 set 为空集合。sigfillset函数把每个信号都添加到 set 中。sigaddset 函数把 signum 添加到 set中。sigdelset 从 set 中删除 signum。如果 signum是 set 的成员，那么 sigismember 返回 1，否则返回 0。</p>
<h3 id="8-5-5-编写信号处理程序"><a href="#8-5-5-编写信号处理程序" class="headerlink" title="8.5.5 编写信号处理程序"></a>8.5.5 编写信号处理程序</h3><p>信号处理是 Linux 系统编程最棘手的一个问题。处理程序有几个属性使得它们很难推理分析：1)处理程序与主程序并发运行，共享同样的全局变量，因此可能与主程序和其他处理程序互相干扰；2)如何以及何时接收信号的规则常常有违人的直觉；3)不同的系统有不同的信号处理语义。</p>
<p>在本节中，我们将讲述这些问题，介绍编写安全、正确和可移植的信号处理程序的一些基本规则。</p>
<p><strong>1. 安全的信号处理</strong></p>
<p>GO. 处理程序要尽可能简单<br>G1. 在处理程序中只调用异步信号安全的函数<br>G2. 保存和恢复 errno<br>G3. 阻塞所有的信号<br>G4. 用 volatile 声明全局变量<br>G5. 用 sig_atomic_t 明标志  </p>
<p><strong>2. 正确的信号处理</strong></p>
<p>信号的一个与直觉不符的方面是未处理的信号是不排队的。</p>
<p><strong>3. 可移植的信号处理</strong></p>
<p>Unix 信号处理的另一个缺陷在于不同的系统有不同的信号处理语义。例如:</p>
<ul>
<li>signal 函数的语义各有不同</li>
<li>系统调用可以被中断</li>
</ul>
<h3 id="8-5-6-同步流以避免讨厌的并发错误"><a href="#8-5-6-同步流以避免讨厌的并发错误" class="headerlink" title="8.5.6 同步流以避免讨厌的并发错误"></a>8.5.6 同步流以避免讨厌的并发错误</h3><p>如何编写读写相同存储位置的并发流程序的问题，困扰着数代计算机科学家。一般而言，流可能交错的数量与指令的数量呈指数关系。这些交错中的一些会产生正确的结果，而有些则不会。基本的问题是以某种方式同步并发流，从而得到最大的可行的交错的集合，每个可行的交错都能得到正确的结果。</p>
<h3 id="8-5-7-显式地等待信号"><a href="#8-5-7-显式地等待信号" class="headerlink" title="8.5.7 显式地等待信号"></a>8.5.7 显式地等待信号</h3><p>有时候主程序需要显式地等待某个信号处理程序运行。例如，当 Linux shell 创建一个前台作业时，在接收下一条用户命令之前，它必须等待作业终止，被 SIGCHLD 处理程序回收。</p>
<h2 id="8-6-非本地跳转"><a href="#8-6-非本地跳转" class="headerlink" title="8.6 非本地跳转"></a>8.6 非本地跳转</h2><p>C 语言提供了一种用户级异常控制流形式，称为非本地跳转(nonlocal jump), 它将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用-返回序列。非本地跳转是通过 setjmp 和 longjmp 函数来提供的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setjmp</span><span class="params">(jmp_buf env)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigsetjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> savesigs)</span>;</span><br><span class="line"><span class="comment">// 返回：setjmp 返回 0 , longjmp 返回非零。</span></span><br></pre></td></tr></table></figure>

<p>setjmp 函数在 env 缓冲区中保存当前调用环境，以供后面的 longjmp 使用，并返回0。 调用环境包括程序计数器、栈指针和通用目的寄存器。出于某种超出本书描述范围的原因，setjmp 返回的值不能被赋值给变量：</p>
<blockquote>
<p>rc &#x3D; setjmp(env); &#x2F;* Wrong! *&#x2F;</p>
</blockquote>
<p>不过它可以安全地用在 switch 或条件语句的测试中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">longjmp</span><span class="params">(jmp_buf env, <span class="type">int</span> retval)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">siglongjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> retval)</span>;</span><br><span class="line"><span class="comment">// 从不返回。</span></span><br></pre></td></tr></table></figure>

<p>longjmp 函数从 env 缓冲区中恢复调用环境，然后触发一个从最近一次初始化的 setjmp 调用的返回。然后 setjmp 返回，并带有非零的返回值 retval。</p>
<p>第一眼看过去，setimp 和 longjmp 之间的相互关系令人迷惑。setjmp 函数只被调用一次，但返回多次：一次是当第一次调用 setjmp 而调用环境保存在缓冲区 env 中时一次是为每个相应的 longjmp 调用。另一方面，longjmp 函数被调用一次，但从不返回。</p>
<h2 id="8-7-操作进程的工具"><a href="#8-7-操作进程的工具" class="headerlink" title="8.7 操作进程的工具"></a>8.7 操作进程的工具</h2><p>Linux 系统提供了大量的监控和操作进程的有用工具。</p>
<p>STRACE: 打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。对于好奇的学生而言，这是一个令人着迷的工具。用-static 编译你的程序，能得到一个更干净的、不带有大量与共享库相关的输出的轨迹。</p>
<p>PS: 列出当前系统中的进程（包括僵死进程）。</p>
<p>TOP: 打印出关于当前进程资源使用的信息。</p>
<p>PMAP: 显示进程的内存映射。</p>
<p>&#x2F;proc: —个虚拟文件系统，以 ASCII 文本格式输出大量内核数据结构的内容，用户程序可以读取这些内容。比如，输入 cat&#x2F;proc&#x2F;loadavg， 可以看到你的 Linux 系统上当前的平均负载。</p>
<h2 id="8-8-小结"><a href="#8-8-小结" class="headerlink" title="8.8 小结"></a>8.8 小结</h2><p>异常控制流(ECF)发生在计算机系统的各个层次，是计算机系统中提供并发的基本机制。</p>
<p>在硬件层，异常是由处理器中的事件触发的控制流中的突变。控制流传递给一个软件处理程序，该处理程序进行一些处理，然后返回控制给被中断的控制流。</p>
<p>有四种不同类型的异常：中断、故障、终止和陷阱。当一个外部 I&#x2F;O 设备（例如定时器芯片或者磁盘控制器）设置了处理器芯片上的中断管脚时，（对于任意指令）中断会异步地发生。控制返回到故障指令后面的那条指令。一条指令的执行可能导致故障和终止同步发生。故障处理程序会重新启动故障指令，而终止处理程序从不将控制返回给被中断的流。最后，陷阱就像是用来实现向应用提供到操作系统代码的受控的人口点的系统调用的函数调用。</p>
<p>在操作系统层，内核用 ECF 提供进程的基本概念。进程提供给应用两个重要的抽象：1)逻辑控制流，它提供给每个程序一个假象，好像它是在独占地使用处理器，2)私有地址空间，它提供给每个程序一个假象，好像它是在独占地使用主存。</p>
<p>在操作系统和应用程序之间的接口处，应用程序可以创建子进程，等待它们的子进程停止或者终止，运行新的程序，以及捕获来自其他进程的信号。信号处理的语义是微妙的，并且随系统不同而不同。然而，在与 Posix 兼容的系统上存在着一些机制，允许程序清楚地指定期望的信号处理语义。</p>
<p>最后，在应用层，C 程序可以使用非本地跳转来规避正常的调用&#x2F;返回栈规则，并且直接从一个函数分支到另一个函数。</p>

  </div>
  </br>
  </br>
  
  <section id="comments" class="comments">
    <div class="valine-comment"></div>
<!--载入js，在</body>之前插入即可-->
<!--Leancloud 操作库:-->
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<!--Valine 的核心代码库-->
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
new Valine({
    el: '.valine-comment',
    app_id: 'aVoW8Ns48PCL9aWpyaraklyz-gzGzoHsz',
    app_key: '5OofdgauZeSJ0SPHIgbbQ6fe',
    placeholder: '',
    visitor: 'true',
  })
</script>
  </section>
  
</article>
    </main>
    <footer id="footer">
  Copyright &copy;
  2023
  Yu Peng
  
  
    <a class="social-links" target="_blank" rel="noopener" href="https://github.com/yuhua2000"><i class="blogfont"><img src="https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/github.svg" alt="GitHub" width="16" height="16"> </i></a>
  
    <a class="social-links" target="_blank" rel="noopener" href="https://leetcode.cn/u/yu-peng-f"><i class="blogfont"><img src="https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/leetcode.svg" alt="LeetCode" width="16" height="16"> </i></a>
  
    <a class="social-links" href="mailto:2651034096@qq.com"><i class="blogfont"><img src="https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/gmail.svg" alt="Mail" width="16" height="16"> </i></a>
  
  
</footer>
    <!-- scripts -->

<script src="/scripts/main.js"></script>

  </body>
</html>