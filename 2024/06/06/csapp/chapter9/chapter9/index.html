<!DOCTYPE html>
<html  lang=en>
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  
    
    <link rel="shortcut icon" href="/images/favicon.ico ">
    
    
    <link rel="icon" type="image/png" href="/images/favicon-android.png " sizes="192x192">
    
    
    <link rel="apple-touch-icon" href="/images/favicon-apple.png " sizes="180x180">
    
  
  <!-- title -->
  <title>Yu Peng blog 第九章 虚拟内存 </title>
  <!-- styles -->
  <!-- styles -->

<link rel="stylesheet" href="/styles/global.css">

  <!-- rss -->
  
<meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <header id="header">
  
  <nav class="menu menu--right">
  
    <a class="menu__item" href="/">主页</a>
    <a class="menu__item" href="/archives/">归档</a>
    <a class="menu__item" href="/categories/">专题</a>
    <a class="menu__item" href="/tags/">标签</a>
    <a class="menu__item" href="/works/">作品</a>
    <a class="menu__item" href="/about/">关于</a>
  </nav>
</header>
    <main>
      <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post__header">
  <h1 class="post__title">第九章 虚拟内存</h1>
  
  
  <div class="post__meta">
    
<time class="post__date" datetime="2024-06-06T12:48:39.000Z" itemprop="datePublished">
  
  <i class="blogfont">&#xedff;</i>
  
  2024-06-06 20:48:39
</time>

    
<div class="post__category">
  <i class="blogfont">&#xe62d;</i>
  <a class="category-link" href="/categories/csapp/">csapp</a>
</div>
  

    
<div class="post__tag">
  <i class="blogfont">&#xe7ec;</i>
  <a class="tag-link-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a>
</div>


    <div id="/2024/06/06/csapp/chapter9/chapter9/" class="leancloud_visitors post__stat" data-flag-title="第九章 虚拟内存">
  <i class="blogfont">&#xe672;</i>
  <span class="leancloud-visitors-count">loading...</span>
</div>
  </div>
</header>
  <aside class="post__aside">
  <div class="post__actions">
    <a id="backTop" class="post__top" href="javascript:">
      <i class="blogfont">&#xe6b1;</i><!-- Top -->
    </a>
    <a id="share" class="post__share" href="javascript:">
      <i class="blogfont">&#xe6c1;</i>
    </a>
  </div>
  <ol class="post__toc"><li class="post__toc-item post__toc-level-1"><a class="post__toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="post__toc-text">虚拟内存</span></a><ol class="post__toc-child"><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#9-1-%E7%89%A9%E7%90%86%E5%92%8C%E8%99%9A%E6%8B%9F%E5%AF%BB%E5%9D%80"><span class="post__toc-text">9.1 物理和虚拟寻址</span></a></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#9-2-%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="post__toc-text">9.2 地址空间</span></a></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#9-3-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="post__toc-text">9.3 虚拟内存作为缓存的工具</span></a><ol class="post__toc-child"><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#9-3-1-DRAM-%E7%BC%93%E5%AD%98%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84"><span class="post__toc-text">9.3.1 DRAM 缓存的组织结构</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#9-3-2-%E9%A1%B5%E8%A1%A8"><span class="post__toc-text">9.3.2 页表</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#9-3-3-%E9%A1%B5%E5%91%BD%E4%B8%AD"><span class="post__toc-text">9.3.3 页命中</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#9-3-4-%E7%BC%BA%E9%A1%B5"><span class="post__toc-text">9.3.4 缺页</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#9-3-5-%E5%88%86%E9%85%8D%E9%A1%B5%E9%9D%A2"><span class="post__toc-text">9.3.5 分配页面</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#9-3-6-%E5%8F%88%E6%98%AF%E5%B1%80%E9%83%A8%E6%80%A7%E6%95%91%E4%BA%86%E6%88%91%E4%BB%AC"><span class="post__toc-text">9.3.6 又是局部性救了我们</span></a></li></ol></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#9-4-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%BD%9C%E4%B8%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="post__toc-text">9.4 虚拟内存作为内存管理的工具</span></a></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#9-5-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%BD%9C%E4%B8%BA%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="post__toc-text">9.5 虚拟内存作为内存保护的工具</span></a></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#9-6-%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91"><span class="post__toc-text">9.6 地址翻译</span></a><ol class="post__toc-child"><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#9-6-1-%E7%BB%93%E5%90%88%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="post__toc-text">9.6.1 结合高速缓存和虚拟内存</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#9-6-2-%E5%88%A9%E7%94%A8-TLB-%E5%8A%A0%E9%80%9F%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91"><span class="post__toc-text">9.6.2 利用 TLB 加速地址翻译</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#9-6-3-%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="post__toc-text">9.6.3 多级页表</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#9-6-4-%E7%BB%BC%E5%90%88%EF%BC%9A%E7%AB%AF%E5%88%B0%E7%AB%AF%E7%9A%84%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91"><span class="post__toc-text">9.6.4 综合：端到端的地址翻译</span></a></li></ol></li></ol></li></ol>
</aside>
  <div class="post__content" itemprop="articleBody">
    <h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><p>一个系统中的进程是与其他进程共享 CPU 和主存资源的。然而，共享主存会形成一些特殊的挑战。随着对 CPU 需求的增长，进程以某种合理的平滑方式慢了下来。但是如果太多的进程需要太多的内存，那么它们中的一些就根本无法运行。当一个程序没有空间可用时，那就是它运气不好了。内存还很容易被破坏。如果某个进程不小心写了另一个进程使用的内存，它就可能以某种完全和程序逻辑无关的令人迷惑的方式失败。</p>
<p>为了更加有效地管理内存并且少出错，现代系统提供了一种对主存的抽象概念，叫做虚拟内存(VM)。虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的和私有的地址空间。通过一个很清晰的机制，虚拟内存提供了三个重要的能力：1)它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。2)它为每个进程提供了一致的地址空间从而简化了内存管理。3)它保护了每个进程的地址空间不被其他进程破坏。</p>
<p>虚拟内存是计算机系统最重要的概念之一。它成功的一个主要原因就是因为它是沉默地、自动地工作的，不需要应用程序员的任何干涉。既然虚拟内存在幕后工作得如此之<br>好，为什么程序员还需要理解它呢？有以下几个原因：</p>
<ul>
<li>虚拟内存是核心的</li>
<li>虚拟内存是强大的</li>
<li>虚拟内存是危险的</li>
</ul>
<h2 id="9-1-物理和虚拟寻址"><a href="#9-1-物理和虚拟寻址" class="headerlink" title="9.1 物理和虚拟寻址"></a>9.1 物理和虚拟寻址</h2><p>计算机系统的主存被组织成一个由 M 个连续的字节大小的单元组成的数组。每字节都有一个唯一的物理地址(Physical Address PA)第一个字节的地址为 0, 接下来的字节地址为 1，再下一个为 2, 依此类推。给定这种简单的结构，CPU 访问内存的最自然的方式就是使用物理地址。我们把这种方式称为物理寻址(physical addressing)。图 9-1 展示了一个物理寻址的示例，该示例的上下文是一条加载指令，它读取从物理地址 4 处开始的 4 字节字。当 CPU 执行这条加载指令时，会生成一个有效物理地址，通过内存总线，把它传递给主存。主存取出从物理地址 4 处开始的 4 字节字，并将它返回给 CPU, CPU 会将它存放在一个寄存器里。</p>
<p><img src="/image/caspp/chapter9/9-1.jpg"><br>图 9-1 一个使用物理寻址的系统</p>
<p>早期的 PC 使用物理寻址，而且诸如数字信号处理器、嵌入式微控制器以及 Cray 超级计算机这样的系统仍然继续使用这种寻址方式。然而，现代处理器使用的是一种称为虚拟寻址(virtual addressing)的寻址形式，参见图 9-2。</p>
<p><img src="/image/caspp/chapter9/9-2.jpg"><br>图 9-2 —个使用虚拟寻址的系统</p>
<p>使用虚拟寻址，CPU 通过生成一个虚拟地址(Virtual Address VA)来访问主存，这个虚拟地址在被送到内存之前先转换成适当的物理地址。将一个虚拟地址转换为物理地址的任务叫做地址翻译(address translation)。 就像异常处理一样，地址翻译需要 CPU 硬件和操作系统之间的紧密合作。CPU 芯片上叫做内存管理单元(Memory Management Unit,MMU)的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容由操作系统管理。</p>
<h2 id="9-2-地址空间"><a href="#9-2-地址空间" class="headerlink" title="9.2 地址空间"></a>9.2 地址空间</h2><p>地址空间(address space)是一个非负整数地址的有序集合:<br>{0 ,1 , 2 , ··· }<br>如果地址空间中的整数是连续的，那么我们说它是一个线性地址空间(linear address space)。 为了简化讨论，我们总是假设使用的是线性地址空间。在一个带虚拟内存的系统中，CPU 从一个有 N &#x3D;2<sup>n</sup>个地址的地址空间中生成虚拟地址，这个地址空间称为虚拟地址空间(virtual address space) :<br>{0 ,1 , 2 , ···, N-1 }<br>一个地址空间的大小是由表示最大地址所需要的位数来描述的。例如，一个包含 N&#x3D;2<sup>n</sup>个地址的虚拟地址空间就叫做一个 n 位地址空间。现代系统通常支持 32 位或者 64 位虚拟地址空间。</p>
<p>一个系统还有一个物理地址空间(physical address space)，对应于系统中物理内存的M 个字节：<br>{0 ,1 , 2 , ···, M-1 }<br>M 不要求是 2 的幂，但是为了简化讨论，我们假设M&#x3D;2<sbp>m</sup>。</p>
<p>地址空间的概念是很重要的，因为它清楚地区分了数据对象（字节）和它们的属性（地址）。 一旦认识到了这种区别，那么我们就可以将其推广，允许每个数据对象有多个独立的地址，其中每个地址都选自一个不同的地址空间。这就是虚拟内存的基本思想。主存中的每字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。</p>
<h2 id="9-3-虚拟内存作为缓存的工具"><a href="#9-3-虚拟内存作为缓存的工具" class="headerlink" title="9.3 虚拟内存作为缓存的工具"></a>9.3 虚拟内存作为缓存的工具</h2><p>概念上而言，虚拟内存被组织为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，作为到数组的索引。磁盘上数组的内容被缓存在主存中。和存储器层次结构中其他缓存一样，磁盘（较低层）上的数据被分割成块，这些块作为磁盘和主存(较高层）之间的传输单元。VM 系统通过将虚拟内存分割为称为虚拟页（Virtual Page, VP)的大小固定的块来处理这个问题。每个虚拟页的大小为 字节。类似地，物理内存被分割为物理页(Physical Page, PP)。大小也为 P 字节（物理页也被称为页帧(page frame)）。</p>
<p>在任意时刻，虚拟页面的集合都分为三个不相交的子集：</p>
<ul>
<li>未分配的</li>
<li>缓存的</li>
<li>未缓存的</li>
</ul>
<p>图 9-3 的示例展示了一个有 8 个虚拟页的小虚拟内存。虚拟页 0 和 3 还没有被分配，因此在磁盘上还不存在。虚拟页 1、4 和 6 被缓存在物理内存中。页 2、5 和 7 已经被分配了，但是当前并未缓存在主存中。</p>
<p><img src="/image/caspp/chapter9/9-3.jpg"><br>图 9-3 —个 VM 系统是如何使用主存作为缓存的</p>
<h3 id="9-3-1-DRAM-缓存的组织结构"><a href="#9-3-1-DRAM-缓存的组织结构" class="headerlink" title="9.3.1 DRAM 缓存的组织结构"></a>9.3.1 DRAM 缓存的组织结构</h3><p>为了有助于清晰理解存储层次结构中不同的缓存概念，我们将使用术语 SRAM 缓存来表示位于 CPU 和主存之间的 Ll、L2 和 L3 高速缓存，并且用术语 DRAM 缓存来表示虚拟内存系统的缓存，它在主存中缓存虚拟页。</p>
<p>在存储层次结构中，DRAM 缓存的位置对它的组织结构有很大的影响。回想一下，DRAM 比 SRAM 要 慢大约 10 倍，而磁盘要比 DRAM 慢大约 100 000 多倍。因此，DRAM 缓存中的不命中比起 SRAM 缓存中的不命中要昂贵得多，这是因为 DRAM 缓存不命中要由磁盘来服务，而 SRAM 缓存不命中通常是由基于 DRAM 的主存来服务的。而且，从磁盘的一个扇区读取第一个字节的时间开销比起读这个扇区中连续的字节要慢大约100 000 倍。归根到底，DRAM 缓存的组织结构完全是由巨大的不命中开销驱动的。</p>
<p>因为大的不命中处罚和访问第一个字节的开销，虚拟页往往很大，通常是 4KB~2MB。由于大的不命中处罚，DRAM 缓存是全相联的，即任何虚拟页都可以放置在任何的物理页中。不命中时的替换策略也很重要，因为替换错了虚拟页的处罚也非常之高。因此，与硬件对 SRAM 缓存相比，操作系统对 DRAM 缓存使用了更复杂精密的替换算法。（这些替换算法超出了我们的讨论范围）。 最后，因为对磁盘的访问时间很长，DRAM 缓存总是使用写回，而不是直写。</p>
<h3 id="9-3-2-页表"><a href="#9-3-2-页表" class="headerlink" title="9.3.2 页表"></a>9.3.2 页表</h3><p>同任何缓存一样，虚拟内存系统必须有某种方法来判定一个虚拟页是否缓存在DRAM 中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页中。如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到 DRAM 中，替换这个牺牲页。</p>
<p>这些功能是由软硬件联合提供的，包括操作系统软件、MMU(内存管理单元）中的地址翻译硬件和一个存放在物理内存中叫做页表（page table)的数据结构，页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。操作系统负责维护页表的内容，以及在磁盘与 DRAM 之间来回传送页。</p>
<p>图 9-4 展示了一个页表的基本组织结构。页表就是一个页表条目(Page Table Entry PTE)的数组。虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个 PTE。为了我们的目的，我们将假设每个 PTE 是由一个有效位(valid bit)和一个 n 位地址字段组成的。有效位表明了该虚拟页当前是否被缓存在 DRAM 中。如果设置了有效位，那么地址字段就表示 DRAM 中相应的物理页的起始位置，这个物理页中缓存了该虚拟页。如果没有设置有效位，那么一个空地址表示这个虚拟页还未被分配。否则，这个地址就指向该虚拟页在磁盘上的起始位置。图 9-4 中的示例展示了一个有 8 个虚拟页和 4 个物理页的系统的页表。四个虚拟页(VP 1、VP 2、VP 4 和 VP7)当前被缓存在 DRAM 中。两个页(VPO 和 VP5)还未被分配，而剩下的页(VP 3 和 VP 6)已经被分配了，但是当前还未被缓存。图 9-4 中有一个要点要注意，因为 DRAM 缓存是全相联的，所以任意物理页都可以包含任意虚拟页。</p>
<p><img src="/image/caspp/chapter9/9-4.jpg"><br>图 9-4 页表</p>
<h3 id="9-3-3-页命中"><a href="#9-3-3-页命中" class="headerlink" title="9.3.3 页命中"></a>9.3.3 页命中</h3><p>考虑一下当 CPU 想要读包含在 VP 2 中的虚拟内存的一个字时会发生什么（图 9-5），VP2 被缓存在 DRAM 中。使用我们将在 9.6 节中详细描述的一种技术，地址翻译硬件将虚拟地址作为一个索引来定位 PTE 2, 并从内存中读取它。因为设置了有效位，那么地址翻译硬件就知道 VP 2 是缓存在内存中的了。所以它使用 PTE 中的物理内存地址（该地址指向 PP1中缓存页的起始位置）， 构造出这个字的物理地址。</p>
<p>图 9-5 VM 页命中。对 VP2 中一个字的引用就会命中</p>
<h3 id="9-3-4-缺页"><a href="#9-3-4-缺页" class="headerlink" title="9.3.4 缺页"></a>9.3.4 缺页</h3><p>在虚拟内存的习惯说法中，DRAM 缓存不命中称为缺页(page fault)。图 9-6 展示了在缺页之前我们的示例页表的状态。CPU 引用了 VP 3 中的一个字，VP 3 并未缓存在DRAM 中。地址翻译硬件从内存中读取 PTE 3, 从有效位推断出 VP 3 未被缓存，并且触发一个缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，在此例中就是存放在 PP 3 中的 VP 4。如果 VP 4 已经被修改了，那么内核就会将它复制回磁盘。无论哪种情况，内核都会修改 VP 4 的页表条目，反映出 VP 4 不再缓存在主存中这一事实。</p>
<p><img src="/image/caspp/chapter9/9-6.jpg"><br>图 9-6 VM 缺页（之前）。 对 VP 3 中的字的引用会不命中，从而触发了缺页</p>
<p>接下来，内核从磁盘复制 VP 3 到内存中的 PP 3, 更新 PTE 3，随后返回。当异常处理程序返回时，它会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重发送到地址翻译硬件。但是现在，VP 3 已经缓存在主存中了，那么页命中也能由地址翻译硬件正常处理了。图 9-7 展示了在缺页之后我们的示例页表的状态。</p>
<p><img src="/image/caspp/chapter9/9-7.jpg"><br>图 9-7 VM 缺页（之后）。 缺页处理程序选择 VP 4 作为牺牲页，并从磁盘上用 VP 3 的副本取代它。在缺页<br>处理程序重新启动导致缺页的指令之后，该指令将从内存中正常地读取字，而不会再产生异常</p>
<p>虚拟内存是在 20 世纪 60 年代早期发明的，远在 CPU-内存之间差距的加大引发产生SRAM 缓存之前。因此，虚拟内存系统使用了和 SRAM 缓存不同的术语，即使它们的许多概念是相似的。在虚拟内存的习惯说法中，块被称为页。在磁盘和内存之间传送页的活动叫做交换(swapping)或者页 面调度(paging)。页从磁盘换入（或者页面调入）DRAM 和从DRAM 换出（或者页面调出）磁盘。一直等待，直到最后时刻，也就是当有不命中发生时，才换入页面的这种策略称为按需页 面调度(demand paging)。也可以采用其他的方法，例如尝试着预测不命中，在页面实际被引用之前就换人页面。然而，所有现代系统都使用的是按需页面调度的方式。</p>
<h3 id="9-3-5-分配页面"><a href="#9-3-5-分配页面" class="headerlink" title="9.3.5 分配页面"></a>9.3.5 分配页面</h3><p>图 9-8 展示了当操作系统分配一个新的虚拟内存页时对我们示例页表的影响，例如，调用 malloc 的结果。在这个示例中，VP5 的分配过程是在磁盘上创建空间并更新 PTE 5, 使它指向磁盘上这个新创建的页面。</p>
<p><img src="/image/caspp/chapter9/9-8.jpg"><br>图 9-8 分配一个新的虚拟页商。内核在磁盘上分配 VP5，并且将 PTE 5 指向这个新的位置</p>
<h3 id="9-3-6-又是局部性救了我们"><a href="#9-3-6-又是局部性救了我们" class="headerlink" title="9.3.6 又是局部性救了我们"></a>9.3.6 又是局部性救了我们</h3><p>只要我们的程序有好的时间局部性，虚拟内存系统就能工作得相当好。但是，当然不是所有的程序都能展现良好的时间局部性。如果工作集的大小超出了物理内存的大小，那么程序将产生一种不幸的状态，叫做抖动(thrashing), 这时页面将不断地换进换出。虽然虚拟内存通常是有效的，但是如果一个程序性能慢得像爬一样，那么聪明的程序员会考虑是不是发生了抖动。</p>
<blockquote>
<p>你可以利用 Linux 的 getrusage 函数监测缺页的数量（以及许多其他的信息）。</p>
</blockquote>
<h2 id="9-4-虚拟内存作为内存管理的工具"><a href="#9-4-虚拟内存作为内存管理的工具" class="headerlink" title="9.4 虚拟内存作为内存管理的工具"></a>9.4 虚拟内存作为内存管理的工具</h2><p>在上一节中，我们看到虚拟内存是如何提供一种机制，利用 DRAM 缓存来自通常更大的虚拟地址空间的页面。有趣的是，一些早期的系统，比如 DEC PDP-11&#x2F;70, 支持的是一个比物理内存更小的虚拟地址空间。然而，虚拟地址仍然是一个有用的机制，因为它大大地简化了内存管理，并提供了一种自然的保护内存的方法。</p>
<p>到目前为止，我们都假设有一个单独的页表，将一个虚拟地址空间映射到物理地址空间。实际上，操作系统为每个进程提供了一个独立的页表，因而也就是一个独立的虚拟地址空间。图 9-9展示了基本思想。在这个示例中，进程 i 的页表将 V P1 映射到 PP 2, VP 2 映射到 PP 7。相似地，进程j的页表将VP 1 映射到 PP 7，VP 2 映射到 PP10。注意，多个虚拟页面可以映射到同一个共享物理页面上。</p>
<p><img src="/image/caspp/chapter9/9-9.jpg"><br>图 9-9 VM 如何为进程提供独立的地址空间。操作系统为系统中的每个进程都维护一个独立的页表</p>
<p>按需页面调度和独立的虚拟地址空间的结合，对系统中内存的使用和管理造成了深远的影响。特别地，VM 简化了链接和加载、代码和数据共享，以及应用程序的内存分配。</p>
<ul>
<li>简化链接</li>
<li>简化加载</li>
<li>简化共享</li>
<li>简化内存分配</li>
</ul>
<h2 id="9-5-虚拟内存作为内存保护的工具"><a href="#9-5-虚拟内存作为内存保护的工具" class="headerlink" title="9.5 虚拟内存作为内存保护的工具"></a>9.5 虚拟内存作为内存保护的工具</h2><p>任何现代计算机系统必须为操作系统提供手段来控制对内存系统的访问。不应该允许一个用户进程修改它的只读代码段。而且也不应该允许它读或修改任何内核中的代码和数据结构。不应该允许它读或者写其他进程的私有内存，并且不允许它修改任何与其他进程共享的虚拟页面，除非所有的共享者都显式地允许它这么做（通过调用明确的进程间通信系统调用）。</p>
<p>就像我们所看到的，提供独立的地址空间使得区分不同进程的私有内存变得容易。但是，地址翻译机制可以以一种自然的方式扩展到提供更好的访问控制。因为每次 CPU 生成一个地址时，地址翻译硬件都会读一个 PTE.所以通过在 PTE 上添加一些额外的许可位来控制对一个虚拟页面内容的访问十分简单。图 9-10 展示了大致的思想。</p>
<p><img src="/image/caspp/chapter9/9-10.jpg"><br>图 9-10 用虚拟内存来提供页面级的内存保护</p>
<p>在这个示例中，每个 PTE 中已经添加了三个许可位。SUP 位表示进程是否必须运行在内核(超级用户）模式下才能访问该页。运行在内核模式中的进程可以访问任何页面，但是运行在用户模式中的进程只允许访问那些 SUP 为 0 的页面。READ 位和 WRITE 位控制对页面的读和写访问。例如，如果进程 i 运行在用户模式下，那么它有读 VPO 和读写VP1的权限。然而，不允许它访问 VP2。</p>
<p>如果一条指令违反了这些许可条件，那么 CPU 就触发一个一般保护故障，将控制传递给一个内核中的异常处理程序。Linux shell —般将这种异常报告为“段错误（segmentation fault)。</p>
<h2 id="9-6-地址翻译"><a href="#9-6-地址翻译" class="headerlink" title="9.6 地址翻译"></a>9.6 地址翻译</h2><p><img src="/image/caspp/chapter9/9-11.jpg"><br>图 9-11 地址翻译符号小结</p>
<p>形式上来说，地址翻译是一个 N 元素的虚拟地址空间(VAS)中的元素和一个 M 元素的物理地址空间(PAS)中元素之间的映射，</p>
<blockquote>
<p>MAP:VAS -&gt; PAS U ∅ </p>
</blockquote>
<p>图 9-12 展示了 MMU 如何利用页表来实现这种映射。CPU 中的一个控制寄存器，页表基址寄存器(Page Table Base Register, PTBR)指向当前页表。n 的虚拟地址包含两个部分:一个 p 位的虚拟页 面偏移(Virtual Page Offset，VPO)和一个(n-p)位的虚拟页号(Virtual Page Number, VPN)。MMU 利用VPN 来选择适当的 PTE, 例如，VPNO 选择 PTEO, VPN1选择 PTE1。以此类推。将页表条目中物理页号(Physical Page Number, PPN)和虚拟地址中的 VPO 串联起来，就得到相应的物理地址。注意，因为物理和虚拟页面都是 P 字节的，所以物理页面偏移(Physical Page Offset, PPO)和 VPO 是相同的。</p>
<p><img src="/image/caspp/chapter9/9-12.jpg"><br>图 9-12 使用页表的地址翻译</p>
<h3 id="9-6-1-结合高速缓存和虚拟内存"><a href="#9-6-1-结合高速缓存和虚拟内存" class="headerlink" title="9.6.1 结合高速缓存和虚拟内存"></a>9.6.1 结合高速缓存和虚拟内存</h3><p>在任何既使用虚拟内存又使用 SRAM 髙速缓存的系统中，都有应该使用虚拟地址还是使用物理地址来访问 SRAM 高速缓存的问题。尽管关于这个折中的详细讨论已经超出了我们的讨论范围，但是大多数系统是选择物理寻址的。使用物理寻址，多个进程同时在高速缓存中有存储块和共享来自相同虚拟页面的块成为很简单的事情。而且，高速缓存无需处理保护问题，因为访问权限的检査是地址翻译过程的一部分。</p>
<p>图 9-14 展示了一个物理寻址的高速缓存如何和虚拟内存结合起来。主要的思路是地址翻译发生在高速缓存查找之前。注意，页表条目可以缓存，就像其他的数据字一样。</p>
<p><img src="/image/caspp/chapter9/9-14.jpg"><br>图 9-14 将 VM 与物理寻址的高速缓存结合起来（VA: 虚拟地址。PTEA: 页表条目地址。PTE: 页表条目。PA: 物理地址）</p>
<h3 id="9-6-2-利用-TLB-加速地址翻译"><a href="#9-6-2-利用-TLB-加速地址翻译" class="headerlink" title="9.6.2 利用 TLB 加速地址翻译"></a>9.6.2 利用 TLB 加速地址翻译</h3><p>正如我们看到的，每次 CPU 产生一个虚拟地址，MMU 就必须查阅一个 PTE, 以便将虚拟地址翻译为物理地址。在最糟糕的情况下，这会要求从内存多取一次数据，代价是几十到几百个周期。如果 PTE 碰巧缓存在 L1 中，那么开销就下降到 1 个或 2 个周期。然而，许多系统都试图消除即使是这样的开销，它们在 MMU 中包括了一个关于 PTE 的小的缓存，称为翻译后备缓冲器(Translation Lookaside Buffer, TLB)。</p>
<p>TLB 是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个 PTE 组成的块。TLB 通常有高度的相联度。如图 9-15 所示，用于组选择和行匹配的索引和标记字段是从虚拟地址中的虚拟页号中提取出来的。如果 TLB 有：T&#x3D;2<sup>t</sup>个组，那么 TLB 索引(TLBI)是由VPN 的 t 个最低位组成的，而 TLB 标记(TLBT)是由 VPN 中剩余的位组成的。</p>
<p><img src="/image/caspp/chapter9/9-15.jpg"><br>图 9-15 虚拟地址中用以访问 TLB 的组成部分</p>
<h3 id="9-6-3-多级页表"><a href="#9-6-3-多级页表" class="headerlink" title="9.6.3 多级页表"></a>9.6.3 多级页表</h3><p>到目前为止，我们一直假设系统只用一个单独的页表来进行地址翻译。但是如果我们有一个 32 位的地址空间、4KB 的页面和一个 4 字节的 PTE。那么即使应用所引用的只是虚拟地址空间中很小的一部分，也总是需要一个 4MB 的页表驻留在内存中。对于地址空间为 64 位的系统来说，问题将变得更复杂。</p>
<p>用来压缩页表的常用方法是使用层次结构的页表。用一个具体的示例是最容易理解这个思想的。假设 32 位虚拟地址空间被分为 4KB 的页，而每个页表条目都是 4 字节。还假设在这一时刻，虚拟地址空间有如下形式：内存的前 2K 个页面分配给了代码和数据，接下来的 6K 个页面还未分配，再接下来的 1023 个页面也未分配，接下来的 1 个页面分配给了用户栈。图 9-17 展示了我们如何为这个虚拟地址空间构造一个两级的页表层次结构。</p>
<p><img src="/image/caspp/chapter9/9-17.jpg"><br>图 9-17 一个两级页表层次结构。注意地址是从上往下增加的</p>
<h3 id="9-6-4-综合：端到端的地址翻译"><a href="#9-6-4-综合：端到端的地址翻译" class="headerlink" title="9.6.4 综合：端到端的地址翻译"></a>9.6.4 综合：端到端的地址翻译</h3>
  </div>
  </br>
  </br>
  
  <section id="comments" class="comments">
    <div class="valine-comment"></div>
<!--载入js，在</body>之前插入即可-->
<!--Leancloud 操作库:-->
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<!--Valine 的核心代码库-->
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
new Valine({
    el: '.valine-comment',
    app_id: 'aVoW8Ns48PCL9aWpyaraklyz-gzGzoHsz',
    app_key: '5OofdgauZeSJ0SPHIgbbQ6fe',
    placeholder: '',
    visitor: 'true',
  })
</script>
  </section>
  
</article>
    </main>
    <footer id="footer">
  Copyright &copy;
  2023
  Yu Peng
  
  
    <a class="social-links" target="_blank" rel="noopener" href="https://github.com/yuhua2000"><i class="blogfont">&#xe6b7; </i></a>
  
    <a class="social-links" href="mailto:2651034096@qq.com"><i class="blogfont">&#xe61a; </i></a>
  
  
</footer>
    <!-- scripts -->

<script src="/scripts/main.js"></script>

  </body>
</html>