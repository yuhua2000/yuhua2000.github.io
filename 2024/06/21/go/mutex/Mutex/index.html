<!DOCTYPE html>
<html  lang=en>
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  
    
    <link rel="shortcut icon" href="/images/favicon.ico ">
    
    
    <link rel="icon" type="image/png" href="/images/favicon-android.png " sizes="192x192">
    
    
    <link rel="apple-touch-icon" href="/images/favicon-apple.png " sizes="180x180">
    
  
  <!-- title -->
  <title>Yu Peng blog 锁实现 </title>
  <!-- styles -->
  <!-- styles -->

<link rel="stylesheet" href="/styles/global.css">

  <!-- rss -->
  
<meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <header id="header">
  
  <nav class="menu menu--right">
  
    <a class="menu__item" href="/">主页</a>
    <a class="menu__item" href="/archives/">归档</a>
    <a class="menu__item" href="/categories/">专题</a>
    <a class="menu__item" href="/tags/">标签</a>
    <a class="menu__item" href="/works/">作品</a>
    <a class="menu__item" href="/about/">关于</a>
  </nav>
</header>
    <main>
      <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post__header">
  <h1 class="post__title">锁实现</h1>
  
  
  <div class="post__meta">
    
<time class="post__date" datetime="2024-06-21T11:30:45.000Z" itemprop="datePublished">
  
  <i class="blogfont">&#xedff;</i>
  
  2024-06-21 19:30:45
</time>

    
<div class="post__category">
  <i class="blogfont">&#xe62d;</i>
  <a class="category-link" href="/categories/golang/">golang</a>
</div>
  

    
<div class="post__tag">
  <i class="blogfont">&#xe7ec;</i>
  <a class="tag-link-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="tag">编程语言</a>
</div>


    <div id="/2024/06/21/go/mutex/Mutex/" class="leancloud_visitors post__stat" data-flag-title="锁实现">
  <i class="blogfont">&#xe672;</i>
  <span class="leancloud-visitors-count">loading...</span>
</div>
  </div>
</header>
  <aside class="post__aside">
  <div class="post__actions">
    <a id="backTop" class="post__top" href="javascript:">
      <i class="blogfont">&#xe6b1;</i><!-- Top -->
    </a>
    <a id="share" class="post__share" href="javascript:">
      <i class="blogfont">&#xe6c1;</i>
    </a>
  </div>
  <ol class="post__toc"><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A"><span class="post__toc-text">代码注释</span></a></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#CompareAndSwapInt32"><span class="post__toc-text">CompareAndSwapInt32</span></a></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#%E5%A5%BD%E4%B9%85%E4%B9%8B%E5%89%8D%E5%86%99%E7%9A%84-%E6%88%91%E8%AE%B0%E5%BE%97%E5%BD%93%E6%97%B6%E5%8F%82%E8%80%83%E4%BA%86%E5%88%AB%E7%9A%84%E8%B5%84%E6%96%99-%E4%B8%80%E6%97%B6%E6%89%BE%E4%B8%8D%E8%A7%81%E4%BA%86-%EF%BC%8C%E5%A4%A7%E5%AE%B6%E5%8F%AF%E4%BB%A5%E5%B8%AE%E5%BF%99%E8%AF%84%E8%AE%BA%E4%B8%8B-%E6%88%91%E5%8A%A0%E4%BB%A5%E4%B8%8B%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5%E3%80%82"><span class="post__toc-text">好久之前写的 我记得当时参考了别的资料 一时找不见了 ，大家可以帮忙评论下 我加以下参考链接。</span></a></li></ol>
</aside>
  <div class="post__content" itemprop="articleBody">
    <h2 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright 2009 The Go Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style</span></span><br><span class="line"><span class="comment">// license that can be found in the LICENSE file.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Package sync provides basic synchronization primitives such as mutual</span></span><br><span class="line"><span class="comment">// exclusion locks. Other than the Once and WaitGroup types, most are intended</span></span><br><span class="line"><span class="comment">// for use by low-level library routines. Higher-level synchronization is</span></span><br><span class="line"><span class="comment">// better done via channels and communication.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Values containing the types defined in this package should not be copied.</span></span><br><span class="line"><span class="keyword">package</span> sync</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;internal/race&quot;</span></span><br><span class="line">	<span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">throw</span><span class="params">(<span class="type">string</span>)</span></span> <span class="comment">// provided by runtime</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A Mutex is a mutual exclusion lock.</span></span><br><span class="line"><span class="comment">// The zero value for a Mutex is an unlocked mutex.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A Mutex must not be copied after first use.</span></span><br><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">//三十二位数字</span></span><br><span class="line">	<span class="comment">// ...  2   1   0</span></span><br><span class="line">	<span class="comment">//  ^   ^   ^   ^</span></span><br><span class="line">	<span class="comment">//  |   |   |   |</span></span><br><span class="line">	<span class="comment">//  等  是  是  锁</span></span><br><span class="line">	<span class="comment">//  待  否  否  状</span></span><br><span class="line">	<span class="comment">//  数  饥  唤  态</span></span><br><span class="line">	<span class="comment">//  量  饿  醒</span></span><br><span class="line">	<span class="comment">//		    g</span></span><br><span class="line">	state <span class="type">int32</span></span><br><span class="line"></span><br><span class="line">	sema <span class="type">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A Locker represents an object that can be locked and unlocked.</span></span><br><span class="line"><span class="keyword">type</span> Locker <span class="keyword">interface</span> &#123;</span><br><span class="line">	Lock()</span><br><span class="line">	Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	mutexLocked      = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// mutex is locked   锁状态</span></span><br><span class="line">	mutexWoken                   <span class="comment">// 是否有人被唤醒</span></span><br><span class="line">	mutexStarving                <span class="comment">// 是否处于饥饿状态</span></span><br><span class="line">	mutexWaiterShift = <span class="literal">iota</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Mutex fairness.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Mutex can be in 2 modes of operations: normal and starvation.</span></span><br><span class="line">	<span class="comment">// In normal mode waiters are queued in FIFO order, but a woken up waiter</span></span><br><span class="line">	<span class="comment">// does not own the mutex and competes with new arriving goroutines over</span></span><br><span class="line">	<span class="comment">// the ownership. New arriving goroutines have an advantage -- they are</span></span><br><span class="line">	<span class="comment">// already running on CPU and there can be lots of them, so a woken up</span></span><br><span class="line">	<span class="comment">// waiter has good chances of losing. In such case it is queued at front</span></span><br><span class="line">	<span class="comment">// of the wait queue. If a waiter fails to acquire the mutex for more than 1ms,</span></span><br><span class="line">	<span class="comment">// it switches mutex to the starvation mode.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// In starvation mode ownership of the mutex is directly handed off from</span></span><br><span class="line">	<span class="comment">// the unlocking goroutine to the waiter at the front of the queue.</span></span><br><span class="line">	<span class="comment">// New arriving goroutines don&#x27;t try to acquire the mutex even if it appears</span></span><br><span class="line">	<span class="comment">// to be unlocked, and don&#x27;t try to spin. Instead they queue themselves at</span></span><br><span class="line">	<span class="comment">// the tail of the wait queue.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// If a waiter receives ownership of the mutex and sees that either</span></span><br><span class="line">	<span class="comment">// (1) it is the last waiter in the queue, or (2) it waited for less than 1 ms,</span></span><br><span class="line">	<span class="comment">// it switches mutex back to normal operation mode.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Normal mode has considerably better performance as a goroutine can acquire</span></span><br><span class="line">	<span class="comment">// a mutex several times in a row even if there are blocked waiters.</span></span><br><span class="line">	<span class="comment">// Starvation mode is important to prevent pathological cases of tail latency.</span></span><br><span class="line">	starvationThresholdNs = <span class="number">1e6</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lock locks m.</span></span><br><span class="line"><span class="comment">// If the lock is already in use, the calling goroutine</span></span><br><span class="line"><span class="comment">// blocks until the mutex is available.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() &#123;</span><br><span class="line">	<span class="comment">// Fast path: grab unlocked mutex.//使用sas加锁</span></span><br><span class="line">	<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">		<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">			race.Acquire(unsafe.Pointer(m))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Slow path (outlined so that the fast path can be inlined)</span></span><br><span class="line">	<span class="comment">// 第二种情况：慢上锁，即此刻有竞争对手</span></span><br><span class="line">	m.lockSlow()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> lockSlow() &#123;</span><br><span class="line">	<span class="keyword">var</span> waitStartTime <span class="type">int64</span> <span class="comment">//等待时间</span></span><br><span class="line">	starving := <span class="literal">false</span>       <span class="comment">//我的饥饿状态</span></span><br><span class="line">	awoke := <span class="literal">false</span>          <span class="comment">//我的是否唤醒态</span></span><br><span class="line">	iter := <span class="number">0</span>               <span class="comment">//我的自旋次数</span></span><br><span class="line">	old := m.state          <span class="comment">//当前锁的信息</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// Don&#x27;t spin in starvation mode, ownership is handed off to waiters</span></span><br><span class="line">		<span class="comment">// so we won&#x27;t be able to acquire the mutex anyway.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">//正常模式 并且允许自旋    ==&gt; 看不太懂可以看看 &amp; 和| 操作</span></span><br><span class="line">		<span class="comment">//runtime_canSpin为true的条件</span></span><br><span class="line">		<span class="comment">//1运行在多核 CPU 的机器上</span></span><br><span class="line">		<span class="comment">//2当前 Goroutine 为了获取该锁进入自旋的次数小于四次</span></span><br><span class="line">		<span class="comment">//3当前机器上至少存在一个正在运行的处理器 P 并且处理的运行队列为空</span></span><br><span class="line">		<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line">			<span class="comment">// Active spinning makes sense.</span></span><br><span class="line">			<span class="comment">// Try to set mutexWoken flag to inform Unlock</span></span><br><span class="line">			<span class="comment">// to not wake other blocked goroutines.</span></span><br><span class="line">			<span class="comment">//如果我没有被唤醒 且没有人被唤醒 并且等等的g数量不为0 那么我尝试将自己设置为唤醒态</span></span><br><span class="line">			<span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">				atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">				awoke = <span class="literal">true</span> <span class="comment">//成功则设置自己为唤醒态</span></span><br><span class="line">			&#125;</span><br><span class="line">			runtime_doSpin() <span class="comment">//自旋一次</span></span><br><span class="line">			iter++           <span class="comment">//自旋次数加一</span></span><br><span class="line">			old = m.state    <span class="comment">//更新当前锁的状态</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">new</span> := old</span><br><span class="line">		<span class="comment">// Don&#x27;t try to acquire starving mutex, new arriving goroutines must queue.</span></span><br><span class="line">		<span class="comment">//非饥饿模式加锁 确保锁定标志为1</span></span><br><span class="line">		<span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">new</span> |= mutexLocked</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果锁被占了或者处于饥饿状态 那么就去排队</span></span><br><span class="line">		<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift <span class="comment">//等待的g加1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// The current goroutine switches mutex to starvation mode.</span></span><br><span class="line">		<span class="comment">// But if the mutex is currently unlocked, don&#x27;t do the switch.</span></span><br><span class="line">		<span class="comment">// Unlock expects that starving mutex has waiters, which will not</span></span><br><span class="line">		<span class="comment">// be true in this case.</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果我已经饥饿 并且锁已经被占用</span></span><br><span class="line">		<span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">//那么锁也随之变为饥饿态</span></span><br><span class="line">			<span class="built_in">new</span> |= mutexStarving</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果我是唤醒态</span></span><br><span class="line">		<span class="keyword">if</span> awoke &#123;</span><br><span class="line">			<span class="comment">// The goroutine has been woken from sleep,</span></span><br><span class="line">			<span class="comment">// so we need to reset the flag in either case.</span></span><br><span class="line">			<span class="comment">//但是new不是唤醒态 那就抛出错误</span></span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123;</span><br><span class="line">				throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//重置唤醒标志位</span></span><br><span class="line">			<span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//尝试更新锁的状态为 new 即尝试上面设置的一系列状态 抢锁 排队 饥饿 重置唤醒</span></span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">break</span> <span class="comment">// locked the mutex with CAS</span></span><br><span class="line">				<span class="comment">//抢锁成功 即不在饥饿状态 也没有锁定</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// If we were already waiting before, queue at the front of the queue.</span></span><br><span class="line">			<span class="comment">//判断我的等待时间</span></span><br><span class="line">			queueLifo := waitStartTime != <span class="number">0</span></span><br><span class="line">			<span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123;</span><br><span class="line">				waitStartTime = runtime_nanotime() <span class="comment">//设置开始等待时间</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//原语：如果我之前排过队，这次就把我放到等待队列队首，否则把我放到队尾，并将我挂起</span></span><br><span class="line">			<span class="comment">// 既然未能获取到锁， 那么就使用sleep原语阻塞本goroutine</span></span><br><span class="line">			<span class="comment">// 如果是新来的goroutine,queueLifo=false, 加入到等待队列的尾部，耐心等待</span></span><br><span class="line">			<span class="comment">// 如果是唤醒的goroutine, queueLifo=true, 加入到等待队列的头部</span></span><br><span class="line">			runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="number">1</span>)</span><br><span class="line">			<span class="comment">//判断我的饥饿状态</span></span><br><span class="line">			starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">			old = m.state <span class="comment">//更新锁的状态</span></span><br><span class="line">			<span class="comment">//如果锁处于饥饿状态</span></span><br><span class="line">			<span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// If this goroutine was woken and mutex is in starvation mode,</span></span><br><span class="line">				<span class="comment">// ownership was handed off to us but mutex is in somewhat</span></span><br><span class="line">				<span class="comment">// inconsistent state: mutexLocked is not set and we are still</span></span><br><span class="line">				<span class="comment">// accounted as waiter. Fix that.</span></span><br><span class="line">				<span class="comment">//如果锁没有等待的g 或者 锁被占用 或者锁有g被唤醒 那么互斥状态不一致</span></span><br><span class="line">				<span class="keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="number">0</span> &#123;</span><br><span class="line">					throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// delta是一个中间状态，atomic.AddInt32方法将给锁落实这个状态</span></span><br><span class="line">				delta := <span class="type">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line">				<span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line">					<span class="comment">// 如果现在我不饥饿或者等待锁的就我一个，那么就将锁解除饥饿切换到正常状态。</span></span><br><span class="line">					<span class="comment">// 饥饿模式效率很低，而且一旦有两个g把mutex切换为饥饿模式，那就会死锁。</span></span><br><span class="line">					delta -= mutexStarving</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 原语：给锁落实delta的状态。</span></span><br><span class="line">				atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			awoke = <span class="literal">true</span></span><br><span class="line">			iter = <span class="number">0</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			old = m.state <span class="comment">//不成功 更新当前锁状态</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Acquire(unsafe.Pointer(m))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unlock unlocks m.</span></span><br><span class="line"><span class="comment">// It is a run-time error if m is not locked on entry to Unlock.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A locked Mutex is not associated with a particular goroutine.</span></span><br><span class="line"><span class="comment">// It is allowed for one goroutine to lock a Mutex and then</span></span><br><span class="line"><span class="comment">// arrange for another goroutine to unlock it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock() &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = m.state</span><br><span class="line">		race.Release(unsafe.Pointer(m))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fast path: drop lock bit.</span></span><br><span class="line">	<span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">new</span> != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Outlined slow path to allow inlining the fast path.</span></span><br><span class="line">		<span class="comment">// To hide unlockSlow during tracing we skip one extra frame when tracing GoUnblock.</span></span><br><span class="line">		m.unlockSlow(<span class="built_in">new</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> unlockSlow(<span class="built_in">new</span> <span class="type">int32</span>) &#123;</span><br><span class="line">	<span class="comment">//检测状态是否正常</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//正常状态下</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">		old := <span class="built_in">new</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="comment">// If there are no waiters or a goroutine has already</span></span><br><span class="line">			<span class="comment">// been woken or grabbed the lock, no need to wake anyone.</span></span><br><span class="line">			<span class="comment">// In starvation mode ownership is directly handed off from unlocking</span></span><br><span class="line">			<span class="comment">// goroutine to the next waiter. We are not part of this chain,</span></span><br><span class="line">			<span class="comment">// since we did not observe mutexStarving when we unlocked the mutex above.</span></span><br><span class="line">			<span class="comment">// So get off the way.</span></span><br><span class="line">			<span class="comment">// 如果锁正处在正常模式下，同时 没有等待锁的g 或者 已经有g被唤醒了 或者 锁已经被抢了，就什么也不用做直接返回</span></span><br><span class="line">			<span class="comment">// 如果锁正处在饥饿模式下，也是什么也不用做直接返回</span></span><br><span class="line">			<span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Grab the right to wake someone.</span></span><br><span class="line">			<span class="comment">// 给锁的唤醒标志位置1，表示已经有g被唤醒了，Mutex.state后三位010</span></span><br><span class="line">			<span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line">			<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">				<span class="comment">// 唤醒锁的等待队列头部的一个g</span></span><br><span class="line">				<span class="comment">// 并把g放到p的funq尾部</span></span><br><span class="line">				runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			old = m.state</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Starving mode: handoff mutex ownership to the next waiter, and yield</span></span><br><span class="line">		<span class="comment">// our time slice so that the next waiter can start to run immediately.</span></span><br><span class="line">		<span class="comment">// Note: mutexLocked is not set, the waiter will set it after wakeup.</span></span><br><span class="line">		<span class="comment">// But mutex is still considered locked if mutexStarving is set,</span></span><br><span class="line">		<span class="comment">// so new coming goroutines won&#x27;t acquire it.</span></span><br><span class="line">		<span class="comment">// 锁处在饥饿模式下，直接唤醒锁的等待队列头部的一个g</span></span><br><span class="line">		<span class="comment">//因为在饥饿模式下没人跟刚被唤醒的g抢锁，所以不用设置锁的唤醒标志位</span></span><br><span class="line">		runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CompareAndSwapInt32"><a href="#CompareAndSwapInt32" class="headerlink" title="CompareAndSwapInt32"></a>CompareAndSwapInt32</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// bool Casp1(void **val, void *old, void *new)</span><br><span class="line">// Atomically:</span><br><span class="line">//	if(*val == old)&#123;</span><br><span class="line">//		*val = new;</span><br><span class="line">//		return 1;</span><br><span class="line">//	&#125; else</span><br><span class="line">//		return 0;</span><br><span class="line">TEXT runtime∕internal∕atomic·Casp1(SB), NOSPLIT, $0-25</span><br><span class="line">        // 首先将 ptr 的值放入 BX</span><br><span class="line">	MOVQ	ptr+0(FP), BX</span><br><span class="line">        // 将假设的旧值放入 AX</span><br><span class="line">	MOVQ	old+8(FP), AX</span><br><span class="line">        // 需要比较的新值放入到CX</span><br><span class="line">	MOVQ	new+16(FP), CX</span><br><span class="line">	LOCK</span><br><span class="line">	CMPXCHGQ	CX, 0(BX)</span><br><span class="line">	SETEQ	ret+24(FP)</span><br><span class="line">	RET</span><br></pre></td></tr></table></figure>

<p>MOV 指令有有好几种后缀 MOVB MOVW MOVL MOVQ 分别对应的是 1 字节 、2 字节 、4 字节、8 字节</p>
<blockquote>
<p>TEXT runtime∕internal∕atomic·Cas(SB),NOSPLIT,$0-17，$0-17表示的意思是这个TEXT block运行的时候，需要开辟的栈帧大小是0，而17 &#x3D; 8 + 4 + 4 + 1 &#x3D; sizeof(pointer of int32) + sizeof(int32) + sizeof(int32) + sizeof(bool)（返回值是 bool ，占据 1 个字节）</p>
</blockquote>
<p>FP，是伪寄存器(pseudo) ，里边存的是 Frame Pointer, FP配合偏移 可以指向函数调用参数或者临时变量</p>
<p>MOVQ ptr+0(FP) BX 这一句话是指把函数的第一个参数ptr+0(FP)移动到BX寄存器中</p>
<p>MOVQ代表移动的是8个字节,Q 代表64bit ，参数的引用是 参数名称+偏移(FP),可以看到这里名称用了ptr,并不是val,变量名对汇编不会有什么影响，但是语法上是必须带上的，可读性也会更好些。</p>
<p>LOCK并不是指令，而是一个指令的前缀(instruction prefix)，是用来修饰CMPXCHGL CX,0(BX) 的</p>
<blockquote>
<p>The LOCK prefix ensures that the CPU has exclusive ownership of the appropriate cache line for the duration of the operation, and provides certain additional ordering guarantees. This may be achieved by asserting a bus lock, but the CPU will avoid this where possible. If the bus is locked then it is only for the duration of the locked instruction</p>
</blockquote>
<p>CMPXCHGL 有两个操作数，CX 和 0(BX),0(BX)代表的是val的地址。</p>
<p>CMPXCHGL指令做的事情，首先会把0(BX)里的值和AX寄存器里存的值做比较，如果一样的话会把CX里边存的值保存到0(BX)这块地址里 (虽然这条指令里并没有出现AX，但是还是用到了，汇编里还是有不少这样的情况)</p>
<p>SETEQ 会在AX和CX相等的时候把1写进 ret+16(FP)(否则写 0）</p>
<h2 id="好久之前写的-我记得当时参考了别的资料-一时找不见了-，大家可以帮忙评论下-我加以下参考链接。"><a href="#好久之前写的-我记得当时参考了别的资料-一时找不见了-，大家可以帮忙评论下-我加以下参考链接。" class="headerlink" title="好久之前写的 我记得当时参考了别的资料 一时找不见了 ，大家可以帮忙评论下 我加以下参考链接。"></a>好久之前写的 我记得当时参考了别的资料 一时找不见了 ，大家可以帮忙评论下 我加以下参考链接。</h2>
  </div>
  </br>
  </br>
  
  <section id="comments" class="comments">
    <div class="valine-comment"></div>
<!--载入js，在</body>之前插入即可-->
<!--Leancloud 操作库:-->
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<!--Valine 的核心代码库-->
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
new Valine({
    el: '.valine-comment',
    app_id: 'aVoW8Ns48PCL9aWpyaraklyz-gzGzoHsz',
    app_key: '5OofdgauZeSJ0SPHIgbbQ6fe',
    placeholder: '',
    visitor: 'true',
  })
</script>
  </section>
  
</article>
    </main>
    <footer id="footer">
  Copyright &copy;
  2023
  Yu Peng
  
  
    <a class="social-links" target="_blank" rel="noopener" href="https://github.com/yuhua2000"><i class="blogfont"><img src="https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/github.svg" alt="GitHub" width="16" height="16"> </i></a>
  
    <a class="social-links" target="_blank" rel="noopener" href="https://leetcode.cn/u/yu-peng-f"><i class="blogfont"><img src="https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/leetcode.svg" alt="LeetCode" width="16" height="16"> </i></a>
  
    <a class="social-links" href="mailto:2651034096@qq.com"><i class="blogfont"><img src="https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/gmail.svg" alt="Mail" width="16" height="16"> </i></a>
  
  
</footer>
    <!-- scripts -->

<script src="/scripts/main.js"></script>

  </body>
</html>