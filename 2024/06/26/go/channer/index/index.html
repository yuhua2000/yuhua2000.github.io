<!DOCTYPE html>
<html  lang=en>
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  
    
    <link rel="shortcut icon" href="/images/favicon.ico ">
    
    
    <link rel="icon" type="image/png" href="/images/favicon-android.png " sizes="192x192">
    
    
    <link rel="apple-touch-icon" href="/images/favicon-apple.png " sizes="180x180">
    
  
  <!-- title -->
  <title>Yu Peng blog Go chan </title>
  <!-- styles -->
  <!-- styles -->

<link rel="stylesheet" href="/styles/global.css">

  <!-- rss -->
  
<meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <header id="header">
  
  <nav class="menu menu--right">
  
    <a class="menu__item" href="/">主页</a>
    <a class="menu__item" href="/archives/">归档</a>
    <a class="menu__item" href="/categories/">专题</a>
    <a class="menu__item" href="/tags/">标签</a>
    <a class="menu__item" href="/works/">作品</a>
    <a class="menu__item" href="/about/">关于</a>
  </nav>
</header>
    <main>
      <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post__header">
  <h1 class="post__title">Go chan</h1>
  
  
  <div class="post__meta">
    
<time class="post__date" datetime="2024-06-26T12:49:29.000Z" itemprop="datePublished">
  
  <i class="blogfont">&#xedff;</i>
  
  2024-06-26 20:49:29
</time>

    
<div class="post__category">
  <i class="blogfont">&#xe62d;</i>
  <a class="category-link" href="/categories/golang/">golang</a>
</div>
  

    
<div class="post__tag">
  <i class="blogfont">&#xe7ec;</i>
  <a class="tag-link-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="tag">编程语言</a>, <a class="tag-link-link" href="/tags/%E8%BD%AC%E8%BD%BD/" rel="tag">转载</a>
</div>


    <div id="/2024/06/26/go/channer/index/" class="leancloud_visitors post__stat" data-flag-title="Go chan">
  <i class="blogfont">&#xe672;</i>
  <span class="leancloud-visitors-count">loading...</span>
</div>
  </div>
</header>
  <aside class="post__aside">
  <div class="post__actions">
    <a id="backTop" class="post__top" href="javascript:">
      <i class="blogfont">&#xe6b1;</i><!-- Top -->
    </a>
    <a id="share" class="post__share" href="javascript:">
      <i class="blogfont">&#xe6c1;</i>
    </a>
  </div>
  <ol class="post__toc"><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#hchan"><span class="post__toc-text">hchan</span></a></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#waitq"><span class="post__toc-text">waitq</span></a></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#sudog"><span class="post__toc-text">sudog</span></a></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#hcase"><span class="post__toc-text">hcase</span></a></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#Illustration"><span class="post__toc-text">Illustration</span></a><ol class="post__toc-child"><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#Buffer-free-synchronization"><span class="post__toc-text">Buffer-free (synchronization)</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#Buffered-asynchronous"><span class="post__toc-text">Buffered (asynchronous)</span></a></li></ol></li></ol></li><li class="post__toc-item post__toc-level-1"><a class="post__toc-link" href="#Source-code-analysis"><span class="post__toc-text">Source code analysis</span></a><ol class="post__toc-child"><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#Receiving-and-Sending"><span class="post__toc-text">Receiving and Sending</span></a><ol class="post__toc-child"><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#main"><span class="post__toc-text">main</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#makechan"><span class="post__toc-text">makechan</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#chanrecv1"><span class="post__toc-text">chanrecv1</span></a><ol class="post__toc-child"><li class="post__toc-item post__toc-level-4"><a class="post__toc-link" href="#recv"><span class="post__toc-text">recv</span></a></li><li class="post__toc-item post__toc-level-4"><a class="post__toc-link" href="#acquireSudog"><span class="post__toc-text">acquireSudog</span></a></li><li class="post__toc-item post__toc-level-4"><a class="post__toc-link" href="#releaseSudog"><span class="post__toc-text">releaseSudog</span></a></li></ol></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#chansend1"><span class="post__toc-text">chansend1</span></a><ol class="post__toc-child"><li class="post__toc-item post__toc-level-4"><a class="post__toc-link" href="#send"><span class="post__toc-text">send</span></a></li></ol></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#closechan"><span class="post__toc-text">closechan</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#Summary"><span class="post__toc-text">Summary</span></a></li></ol></li></ol>
</aside>
  <div class="post__content" itemprop="articleBody">
    <h2 id="hchan"><a href="#hchan" class="headerlink" title="hchan"></a>hchan</h2><p>This is the structure of channel.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">	qcount   <span class="type">uint</span>           <span class="comment">// total data in the queue  队列中的数据总数</span></span><br><span class="line">	dataqsiz <span class="type">uint</span>           <span class="comment">// size of the circular queue 环形队列的大小，大于 0 表示有缓冲区，等于 0 表示无缓冲区</span></span><br><span class="line">	buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements 指向元素数组的指针</span></span><br><span class="line">	elemsize <span class="type">uint16</span>         <span class="comment">//单个元素的大小</span></span><br><span class="line">	closed   <span class="type">uint32</span>         <span class="comment">//表示通道是否已关闭的标志。</span></span><br><span class="line">	elemtype *_type         <span class="comment">// element type 元素类型的描述，通常在接口部分编写</span></span><br><span class="line">	sendx    <span class="type">uint</span>           <span class="comment">// send index 发送数组的索引</span></span><br><span class="line">	recvx    <span class="type">uint</span>           <span class="comment">// receive index 接收数组的索引</span></span><br><span class="line">	recvq    waitq          <span class="comment">// list of recv waiters 等待接收数据的 goroutine 列表</span></span><br><span class="line">	sendq    waitq          <span class="comment">// list of send waiters 等待发送数据的 goroutine 列表</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">	<span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Do not change another G&#x27;s status while holding this lock</span></span><br><span class="line">	<span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">	<span class="comment">// with stack shrinking.</span></span><br><span class="line">	lock mutex <span class="comment">//互斥锁，用于保护对通道的并发访问。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="waitq"><a href="#waitq" class="headerlink" title="waitq"></a>waitq</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">	first *sudog <span class="comment">//指向等待队列中的第一个 sudog 结构体的指针。</span></span><br><span class="line">	last  *sudog <span class="comment">//指向等待队列中的最后一个 sudog 结构体的指针。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sudog"><a href="#sudog" class="headerlink" title="sudog"></a>sudog</h2><p>sudog represents a waiting g</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sudog represents a g in a wait list, such as for sending/receiving</span></span><br><span class="line"><span class="comment">// on a channel.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// sudog is necessary because the g ↔ synchronization object relation</span></span><br><span class="line"><span class="comment">// is many-to-many. A g can be on many wait lists, so there may be</span></span><br><span class="line"><span class="comment">// many sudogs for one g; and many gs may be waiting on the same</span></span><br><span class="line"><span class="comment">// synchronization object, so there may be many sudogs for one object.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// sudogs are allocated from a special pool. Use acquireSudog and</span></span><br><span class="line"><span class="comment">// releaseSudog to allocate and free them.</span></span><br><span class="line"><span class="comment">// 用于表示等待队列</span></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// The following fields are protected by the hchan.lock of the</span></span><br><span class="line">	<span class="comment">// channel this sudog is blocking on. shrinkstack depends on</span></span><br><span class="line">	<span class="comment">// this for sudogs involved in channel ops.</span></span><br><span class="line"></span><br><span class="line">	g *g <span class="comment">//指向等待者（goroutine）的 g 结构体的指针</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//next、prev：用于链接 sudog 结构体形成链表，以便在等待队列中进行调度。</span></span><br><span class="line">	next *sudog</span><br><span class="line">	prev *sudog</span><br><span class="line">	elem unsafe.Pointer <span class="comment">// data element (may point to stack) 数据元素的指针</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The following fields are never accessed concurrently.</span></span><br><span class="line">	<span class="comment">// For channels, waitlink is only accessed by g.</span></span><br><span class="line">	<span class="comment">// For semaphores, all fields (including the ones above)</span></span><br><span class="line">	<span class="comment">// are only accessed when holding a semaRoot lock.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//用于记录等待者的获取时间和释放时间。</span></span><br><span class="line">	acquiretime <span class="type">int64</span></span><br><span class="line">	releasetime <span class="type">int64</span></span><br><span class="line">	ticket      <span class="type">uint32</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// isSelect indicates g is participating in a select, so</span></span><br><span class="line">	<span class="comment">// g.selectDone must be CAS&#x27;d to win the wake-up race.</span></span><br><span class="line">	<span class="comment">//isSelect 字段是 sudog 结构体的一个布尔字段，用于指示关联的 goroutine (g) 是否参与了 select 语句</span></span><br><span class="line">	isSelect <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// success indicates whether communication over channel c</span></span><br><span class="line">	<span class="comment">// succeeded. It is true if the goroutine was awoken because a</span></span><br><span class="line">	<span class="comment">// value was delivered over channel c, and false if awoken</span></span><br><span class="line">	<span class="comment">// because c was closed.</span></span><br><span class="line">	success <span class="type">bool</span> <span class="comment">//指示通信是否成功，如果等待者被唤醒是因为从通道接收到值，则为 true；如果被唤醒是因为通道关闭，则为 false。</span></span><br><span class="line">	<span class="comment">// waitlink、waittail：用于链接等待者的链表，通常在等待队列或信号量的根节点中使用</span></span><br><span class="line">	parent   *sudog <span class="comment">// semaRoot binary tree</span></span><br><span class="line">	waitlink *sudog <span class="comment">// g.waiting list or semaRoot</span></span><br><span class="line">	waittail *sudog <span class="comment">// semaRoot</span></span><br><span class="line">	c        *hchan <span class="comment">// channel  指向等待的通道（hchan 结构体）的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="hcase"><a href="#hcase" class="headerlink" title="hcase"></a>hcase</h2><p>This is the structure generated by a case in select</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//scase 结构体用于描述 select 语句中的每个 case 条件，包括通道和相关的数据元素</span></span><br><span class="line"><span class="keyword">type</span> scase <span class="keyword">struct</span> &#123;</span><br><span class="line">   c           *hchan         <span class="comment">// chan</span></span><br><span class="line">   elem        unsafe.Pointer <span class="comment">// data element</span></span><br><span class="line">   kind        <span class="type">uint16</span>  <span class="comment">// Current case type, nil recv send or default</span></span><br><span class="line">   pc          <span class="type">uintptr</span> <span class="comment">// race pc (for race detector / msan)</span></span><br><span class="line">   releasetime <span class="type">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>From the above structure, we can see that the internal essence of channel is a buffer pool + two queues (send recv). So how does the data interact? There is a sketch map on the internet, which shows a more vivid image.</p>
<p>中文：<br>从上面的结构可以看出，通道的内部本质是一个缓冲池加上两个队列（发送队列和接收队列）。那么数据是如何进行交互的呢？网络上有一张示意图，可以更形象地展示这个过程。</p>
<h2 id="Illustration"><a href="#Illustration" class="headerlink" title="Illustration"></a>Illustration</h2><h3 id="Buffer-free-synchronization"><a href="#Buffer-free-synchronization" class="headerlink" title="Buffer-free (synchronization)"></a>Buffer-free (synchronization)</h3><p><img src="/image/go/chan/synchronization.jpg" alt="synchronization"></p>
<h3 id="Buffered-asynchronous"><a href="#Buffered-asynchronous" class="headerlink" title="Buffered (asynchronous)"></a>Buffered (asynchronous)</h3><p><img src="/image/go/chan/asynchronous.jpg" alt="synchronization"></p>
<p>Combining the above structure and illustration, we can probably infer the channel’s send recv process.</p>
<ol>
<li>If it’s a recv (&lt;-channel) request, first determine if someone in a sendq queue is waiting for the data to be placed.<ol>
<li>If the sendq queue is not empty and the buffer pool is not empty, then the sendq queue is waiting to put data. The g of recv takes data from the buffer pool, and then puts the data carried by the first g of sendq into the buf buffer pool.</li>
<li>If sendq is not empty but the buffer pool is empty, then this is chan without buffer pool. I take the first g data from sendq and it’s ok.</li>
<li>If sendq is empty, go to the buffer pool and see if the buffer pool has data, then take it and go.</li>
<li>If sendq is empty and the buffer pool has no data, wait here.</li>
</ol>
</li>
<li>If send, the process is the same as recv</li>
<li>If the channel is closed at this point, wake up all waiting g in the waiting queue (sendq or recvq) and tell them channel.close &#x3D; true</li>
</ol>
<p>Next is tracking the source code, proving and correcting the conjecture.</p>
<p>中文：</p>
<ol>
<li>如果是获取请求，则首先确定在发送队列中是否有数据等待发送<ol>
<li>如果sendq队列不空，缓冲池也不空，那么sendq队列正在等待放入数据。recv的g从缓冲池中获取数据，然后将sendq的第一个g携带的数据放入buf缓冲池。</li>
<li>如果sendq不是空的，但是缓冲池是空的，那么这就是没有缓冲池的chan。我从sendq中取第一个g数据，这没问题。</li>
<li>如果sendq为空，进入缓冲池，看看缓冲池中是否有数据，然后获取数据。</li>
<li>如果sendq为空，并且缓冲池没有数据，则在这里等待。</li>
</ol>
</li>
<li>如果send，处理与recv相同</li>
<li>如果通道此时关闭，唤醒等待队列(sendq或recvq)中的所有等待g，并告诉它们通道关闭。</li>
</ol>
<h1 id="Source-code-analysis"><a href="#Source-code-analysis" class="headerlink" title="Source code analysis"></a>Source code analysis</h1><h2 id="Receiving-and-Sending"><a href="#Receiving-and-Sending" class="headerlink" title="Receiving and Sending"></a>Receiving and Sending</h2><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><p>Let’s use the go tool to analyze how channel generation, C &lt; - i,&lt; - C are implemented at the bottom level.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        c1 &lt;- <span class="number">1</span></span><br><span class="line">        c2 &lt;- <span class="number">2</span></span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;-c1</span><br><span class="line">    &lt;-c2</span><br><span class="line">    <span class="built_in">close</span>(c1)</span><br><span class="line">    <span class="built_in">close</span>(c2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go build -gcflags=all=&quot;-N -l&quot; main.go</span><br><span class="line">go tool objdump -s &quot;main.main&quot; main</span><br></pre></td></tr></table></figure>
<p>After we filter out the CALL</p>
<blockquote>
<p>go tool objdump -s “main.main” main | grep CALL</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">main.go:4             0x459a01                e8faa1faff              CALL runtime.makechan(SB)</span><br><span class="line">main.go:5             0x459a17                e8e4a1faff              CALL runtime.makechan(SB)</span><br><span class="line">main.go:6             0x459a28                e8f31dfbff              CALL runtime.newobject(SB)</span><br><span class="line">main.go:6             0x459a60                e89bd1ffff              CALL runtime.gcWriteBarrierDX(SB)</span><br><span class="line">main.go:6             0x459a8a                e871d1ffff              CALL runtime.gcWriteBarrierDX(SB)</span><br><span class="line">main.go:6             0x459a98                e8a3eafdff              CALL runtime.newproc(SB)</span><br><span class="line">main.go:10            0x459aa4                e8d7adfaff              CALL runtime.chanrecv1(SB)</span><br><span class="line">main.go:11            0x459ab0                e8cbadfaff              CALL runtime.chanrecv1(SB)</span><br><span class="line">main.go:12            0x459aba                e841abfaff              CALL runtime.closechan(SB)</span><br><span class="line">main.go:13            0x459ac4                e837abfaff              CALL runtime.closechan(SB)</span><br><span class="line">main.go:3             0x459ad3                e848cdffff              CALL runtime.morestack_noctxt.abi0(SB)</span><br><span class="line">main.go:7             0x459b12                e869a3faff              CALL runtime.chansend1(SB)</span><br><span class="line">main.go:8             0x459b23                e858a3faff              CALL runtime.chansend1(SB)</span><br><span class="line">main.go:6             0x459b32                e849ccffff              CALL runtime.morestack.abi0(SB)</span><br></pre></td></tr></table></figure>
<ol>
<li>makechan: Functions that create channel s are the same with or without buffers</li>
<li>Chanrecv1: &lt;-c1, the function called</li>
<li>Cloechan: The function called when close (c1) closes channel usage</li>
<li>Chansend1: C1 &lt; - 1, which is the function used to send data</li>
</ol>
<h3 id="makechan"><a href="#makechan" class="headerlink" title="makechan"></a>makechan</h3><p>The main part of creating channel is to allocate memory to the structure and bug buffer pool, and then initialize the structure of hchan.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan &#123;</span><br><span class="line">	elem := t.elem</span><br><span class="line"></span><br><span class="line">	<span class="comment">// compiler checks this but be safe.</span></span><br><span class="line">	<span class="keyword">if</span> elem.size &gt;= <span class="number">1</span>&lt;&lt;<span class="number">16</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;makechan: invalid channel element type&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> hchanSize%maxAlign != <span class="number">0</span> || elem.align &gt; maxAlign &#123;</span><br><span class="line">		throw(<span class="string">&quot;makechan: bad alignment&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mem, overflow := math.MulUintptr(elem.size, <span class="type">uintptr</span>(size))</span><br><span class="line">	<span class="keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.</span></span><br><span class="line">	<span class="comment">// buf points into the same allocation, elemtype is persistent.</span></span><br><span class="line">	<span class="comment">// SudoG&#x27;s are referenced from their owning thread so they can&#x27;t be collected.</span></span><br><span class="line">	<span class="comment">// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.</span></span><br><span class="line">	<span class="keyword">var</span> c *hchan</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> mem == <span class="number">0</span>:</span><br><span class="line">		<span class="comment">// 队列或元素大小为零。</span></span><br><span class="line">		<span class="comment">// Queue or element size is zero.</span></span><br><span class="line">		c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">		<span class="comment">// Race detector uses this location for synchronization.</span></span><br><span class="line">		c.buf = c.raceaddr()</span><br><span class="line">	<span class="keyword">case</span> elem.ptrdata == <span class="number">0</span>:</span><br><span class="line">		<span class="comment">// Elements do not contain pointers.</span></span><br><span class="line">		<span class="comment">// Allocate hchan and buf in one call.</span></span><br><span class="line">		<span class="comment">// 元素不包含指针。</span></span><br><span class="line">		<span class="comment">// 一次性分配 hchan 和 buf。</span></span><br><span class="line">		c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">		c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">// Elements contain pointers.</span></span><br><span class="line">		<span class="comment">// 元素包含指针。</span></span><br><span class="line">		c = <span class="built_in">new</span>(hchan)</span><br><span class="line">		c.buf = mallocgc(mem, elem, <span class="literal">true</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.elemsize = <span class="type">uint16</span>(elem.size)</span><br><span class="line">	c.elemtype = elem</span><br><span class="line">	c.dataqsiz = <span class="type">uint</span>(size)</span><br><span class="line">	lockInit(&amp;c.lock, lockRankHchan)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> debugChan &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;makechan: chan=&quot;</span>, c, <span class="string">&quot;; elemsize=&quot;</span>, elem.size, <span class="string">&quot;; dataqsiz=&quot;</span>, size, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="chanrecv1"><a href="#chanrecv1" class="headerlink" title="chanrecv1"></a>chanrecv1</h3><p>chanrecv1 calls the chanrecv implementation. chanrecv listens to channels and receives data from channels and writes it into ep</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// chanrecv receives on channel c and writes the received data to ep.</span></span><br><span class="line"><span class="comment">// ep may be nil, in which case received data is ignored.</span></span><br><span class="line"><span class="comment">// If block == false and no elements are available, returns (false, false).</span></span><br><span class="line"><span class="comment">// Otherwise, if c is closed, zeros *ep and returns (true, false).</span></span><br><span class="line"><span class="comment">// Otherwise, fills in *ep with an element and returns (true, true).</span></span><br><span class="line"><span class="comment">// A non-nil ep must point to the heap or the caller&#x27;s stack.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>)</span></span> (selected, received <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="comment">// raceenabled: don&#x27;t need to check ep, as it is always on the stack</span></span><br><span class="line">	<span class="comment">// or is new memory allocated by reflect.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> debugChan &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;chanrecv: chan=&quot;</span>, c, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果 c 为空 则根据 block参数决定是否阻塞接收操作</span></span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !block &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">		throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果不是阻塞操作且通道为空，则接收操作失败，返回</span></span><br><span class="line">	<span class="comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span></span><br><span class="line">	<span class="keyword">if</span> !block &amp;&amp; empty(c) &#123;</span><br><span class="line">		<span class="comment">// After observing that the channel is not ready for receiving, we observe whether the</span></span><br><span class="line">		<span class="comment">// channel is closed.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// Reordering of these checks could lead to incorrect behavior when racing with a close.</span></span><br><span class="line">		<span class="comment">// For example, if the channel was open and not empty, was closed, and then drained,</span></span><br><span class="line">		<span class="comment">// reordered reads could incorrectly indicate &quot;open and empty&quot;. To prevent reordering,</span></span><br><span class="line">		<span class="comment">// we use atomic loads for both checks, and rely on emptying and closing to happen in</span></span><br><span class="line">		<span class="comment">// separate critical sections under the same lock.  This assumption fails when closing</span></span><br><span class="line">		<span class="comment">// an unbuffered channel with a blocked send, but that is an error condition anyway.</span></span><br><span class="line">		<span class="comment">// 如果通道未关闭，则返回</span></span><br><span class="line">		<span class="keyword">if</span> atomic.Load(&amp;c.closed) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// Because a channel cannot be reopened, the later observation of the channel</span></span><br><span class="line">			<span class="comment">// being not closed implies that it was also not closed at the moment of the</span></span><br><span class="line">			<span class="comment">// first observation. We behave as if we observed the channel at that moment</span></span><br><span class="line">			<span class="comment">// and report that the receive cannot proceed.</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// The channel is irreversibly closed. Re-check whether the channel has any pending data</span></span><br><span class="line">		<span class="comment">// to receive, which could have arrived between the empty and closed checks above.</span></span><br><span class="line">		<span class="comment">// Sequential consistency is also required here, when racing with such a send.</span></span><br><span class="line">		<span class="keyword">if</span> empty(c) &#123;</span><br><span class="line">			<span class="comment">// The channel is irreversibly closed and empty.</span></span><br><span class="line">			<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">				raceacquire(c.raceaddr())</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">				typedmemclr(c.elemtype, ep)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> t0 <span class="type">int64</span></span><br><span class="line">	<span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">		t0 = cputicks()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果通道已关闭且缓冲区中没有待接收的元素，则接收操作失败，返回</span></span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquire(c.raceaddr())</span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemclr(c.elemtype, ep)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从发送队列中获取一个等待的发送者，如果存在则直接接收值并返回</span></span><br><span class="line">	<span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Found a waiting sender. If buffer is size 0, receive value</span></span><br><span class="line">		<span class="comment">// directly from sender. Otherwise, receive from head of queue</span></span><br><span class="line">		<span class="comment">// and add sender&#x27;s value to the tail of the queue (both map to</span></span><br><span class="line">		<span class="comment">// the same buffer slot because the queue is full).</span></span><br><span class="line">		recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果通道的缓冲区中有元素，则直接接收值并返回</span></span><br><span class="line">	<span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Receive directly from queue</span></span><br><span class="line">		qp := chanbuf(c, c.recvx)</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			racenotify(c, c.recvx, <span class="literal">nil</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">		&#125;</span><br><span class="line">		typedmemclr(c.elemtype, qp)</span><br><span class="line">		c.recvx++</span><br><span class="line">		<span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">			c.recvx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.qcount--</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果不是阻塞操作，则返回不选定接收操作</span></span><br><span class="line">	<span class="keyword">if</span> !block &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 准备阻塞接收操作</span></span><br><span class="line">	<span class="comment">// no sender available: block on this channel.</span></span><br><span class="line">	gp := getg()</span><br><span class="line">	mysg := acquireSudog()</span><br><span class="line">	mysg.releasetime = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">		mysg.releasetime = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line">	<span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">	mysg.elem = ep</span><br><span class="line">	mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">	gp.waiting = mysg</span><br><span class="line">	mysg.g = gp</span><br><span class="line">	mysg.isSelect = <span class="literal">false</span></span><br><span class="line">	mysg.c = c</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	c.recvq.enqueue(mysg)</span><br><span class="line">	<span class="comment">// Signal to anyone trying to shrink our stack that we&#x27;re about</span></span><br><span class="line">	<span class="comment">// to park on a channel. The window between when this G&#x27;s status</span></span><br><span class="line">	<span class="comment">// changes and when we set gp.activeStackChans is not safe for</span></span><br><span class="line">	<span class="comment">// stack shrinking.</span></span><br><span class="line">	atomic.Store8(&amp;gp.parkingOnChan, <span class="number">1</span>)</span><br><span class="line">	gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// someone woke us up</span></span><br><span class="line">	<span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">		throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	gp.waiting = <span class="literal">nil</span></span><br><span class="line">	gp.activeStackChans = <span class="literal">false</span></span><br><span class="line">	<span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">		blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	success := mysg.success</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	mysg.c = <span class="literal">nil</span></span><br><span class="line">	releaseSudog(mysg)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>, success</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>From the above logic, we can see four possibilities of data transmission.</p>
<ul>
<li>Sendq queue is not empty, but buf is empty (in the case of synchronous blocking g): get sudog of sendq queue head and copy sudog.elem data to the target address ep</li>
<li>Sendq queue is not empty, buf is not empty (in the case of asynchronous blocking g g): copy the buf header element to the target address ep, get sudog of sendq queue header, and then copy the sudog.elem data to the end of the buf queue, release sudog</li>
<li>sendq queue is empty, but buf is not empty (in the case of asynchronous non-blocking g): copy the buf header element to the target address ep</li>
<li>sendq queue is empty and buf is empty (synchronous non-blocking g case): at this time, you need to block yourself, get a sudog structure, put it in channel’s recvq queue, wait for send g to wake up and copy your data to the target address</li>
</ul>
<p>If you think about it, you will find a problem. After L66 goparkunlock (&amp; C. lock, waitReason ChanReceive, traceEvGoBlockRecv, 3) hibernates g above, G is woken up and continues to execute from here, as if there is no logic to show that the recv g gets the data, and this G is blocked here for equivalence. So far, but none of the following logic operates on data?</p>
<p>The recv method that follows is understandable</p>
<p>中文：<br>从上面的逻辑中，我们可以看到数据传输的四种可能性。</p>
<ul>
<li>sendq 队列不为空，但 buf 为空（同步阻塞的 g 的情况）：获取 sendq 队列头的 sudog，将 sudog.elem 的数据复制到目标地址 ep。</li>
<li>sendq 队列不为空，buf 也不为空（异步阻塞的 g 的情况）：将 buf 的头元素复制到目标地址 ep，获取 sendq 队列头的 sudog，然后将 sudog.elem 的数据复制到 buf 队列的末尾，释放 sudog。</li>
<li>sendq 队列为空，但 buf 不为空（异步非阻塞的 g 的情况）：将 buf 的头元素复制到目标地址 ep。</li>
<li>sendq 队列为空，buf 也为空（同步非阻塞的 g 的情况）：此时，需要阻塞自己，获取一个 sudog 结构，将其放入通道的 recvq 队列中，等待发送的 g 唤醒并将数据复制到目标地址。</li>
</ul>
<p>如果仔细思考，您会发现一个问题。在上面的代码中，当 G 执行到 L66 的 goparkunlock(&amp;c.lock, waitReason | ChanReceive, traceEvGoBlockRecv, 3) 时，G 会进入休眠状态，就好像没有逻辑来表明接收的 G 获取到数据，而此时的 G 在此被阻塞，而后续的逻辑都没有操作数据。</p>
<h4 id="recv"><a href="#recv" class="headerlink" title="recv"></a>recv</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// recv processes a receive operation on a full channel c.</span></span><br><span class="line"><span class="comment">// There are 2 parts:</span></span><br><span class="line"><span class="comment">// 1) The value sent by the sender sg is put into the channel</span></span><br><span class="line"><span class="comment">//    and the sender is woken up to go on its merry way.</span></span><br><span class="line"><span class="comment">// 2) The value received by the receiver (the current G) is</span></span><br><span class="line"><span class="comment">//    written to ep.</span></span><br><span class="line"><span class="comment">// For synchronous channels, both values are the same.</span></span><br><span class="line"><span class="comment">// For asynchronous channels, the receiver gets its data from</span></span><br><span class="line"><span class="comment">// the channel buffer and the sender&#x27;s data is put in the</span></span><br><span class="line"><span class="comment">// channel buffer.</span></span><br><span class="line"><span class="comment">// Channel c must be full and locked. recv unlocks c with unlockf.</span></span><br><span class="line"><span class="comment">// sg must already be dequeued from c.</span></span><br><span class="line"><span class="comment">// A non-nil ep must point to the heap or the caller&#x27;s stack.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="comment">// 非缓存型的</span></span><br><span class="line">	<span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			racesync(c, sg) <span class="comment">// 数据竞争检测：同步通道和发送者</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// copy data from sender</span></span><br><span class="line">			recvDirect(c.elemtype, sg, ep) <span class="comment">// 从发送者直接复制数据</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Queue is full. Take the item at the</span></span><br><span class="line">		<span class="comment">// head of the queue. Make the sender enqueue</span></span><br><span class="line">		<span class="comment">// its item at the tail of the queue. Since the</span></span><br><span class="line">		<span class="comment">// queue is full, those are both the same slot.</span></span><br><span class="line">		<span class="comment">// 缓冲区已满，从队列头部取出元素，并让发送者将其放入队列尾部</span></span><br><span class="line">		qp := chanbuf(c, c.recvx) <span class="comment">// 获取队列头部元素地址</span></span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			racenotify(c, c.recvx, <span class="literal">nil</span>) <span class="comment">// 数据竞争检测：通知接收者正在读取该位置的元素</span></span><br><span class="line">			racenotify(c, c.recvx, sg)  <span class="comment">// 数据竞争检测：通知发送者正在写入该位置的元素</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 从队列复制数据到接收者</span></span><br><span class="line">		<span class="comment">// copy data from queue to receiver</span></span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 从发送者复制数据到队列</span></span><br><span class="line">		<span class="comment">// copy data from sender to queue</span></span><br><span class="line">		typedmemmove(c.elemtype, qp, sg.elem)</span><br><span class="line">		c.recvx++ <span class="comment">// 更新接收索引</span></span><br><span class="line">		<span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">			c.recvx = <span class="number">0</span> <span class="comment">// 接收索引达到缓冲区末尾，重置为0</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.sendx = c.recvx <span class="comment">// c.sendx = (c.sendx+1) % c.dataqsiz // 发送索引与接收索引相同，队列已满</span></span><br><span class="line">	&#125;</span><br><span class="line">	sg.elem = <span class="literal">nil</span></span><br><span class="line">	gp := sg.g</span><br><span class="line">	unlockf() <span class="comment">// 解锁通道</span></span><br><span class="line">	gp.param = unsafe.Pointer(sg)</span><br><span class="line">	sg.success = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">		sg.releasetime = cputicks() <span class="comment">// 记录释放时间</span></span><br><span class="line">	&#125;</span><br><span class="line">	goready(gp, skip+<span class="number">1</span>) <span class="comment">// 唤醒接收者的goroutine</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Combining the above logic, we find that before g is waked up, the sudog data associated with g is already used by channel, so when g is waked up, there is no need to deal with the logic related to data transmission.</p>
<h4 id="acquireSudog"><a href="#acquireSudog" class="headerlink" title="acquireSudog"></a>acquireSudog</h4><p>Get a sudog structure, which uses the two-level cache of p scheme, i.e. local cache of an array of sudog, just like the queues of cache and scheduler scheduler scheduled to run g. At the same time, a linked list of sudog cache is maintained on the global scheme structure. When p local sudog is insufficient or excessive, go ahead. Balancing with global sched</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">acquireSudog</span><span class="params">()</span></span> *sudog &#123;</span><br><span class="line">    <span class="comment">// Lock up</span></span><br><span class="line">    mp := acquirem()<span class="comment">// 获取当前的 m （线程）上下文</span></span><br><span class="line">    pp := mp.p.ptr()<span class="comment">// 获取 p （处理器）上下文</span></span><br><span class="line">    <span class="comment">// If the current cache does not have sudog, then go to the global scheme and pull some sudog caches in batches to the current p</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pp.sudogcache) == <span class="number">0</span> &#123;</span><br><span class="line">        lock(&amp;sched.sudoglock)<span class="comment">// 锁定全局 sudog 缓存</span></span><br><span class="line">        <span class="comment">// First, try to grab a batch from central cache.</span></span><br><span class="line">        <span class="comment">// 首先，尝试从中央缓存中获取一批 sudog</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(pp.sudogcache) &lt; <span class="built_in">cap</span>(pp.sudogcache)/<span class="number">2</span> &amp;&amp; sched.sudogcache != <span class="literal">nil</span> &#123;</span><br><span class="line">            s := sched.sudogcache</span><br><span class="line">            sched.sudogcache = s.next</span><br><span class="line">            s.next = <span class="literal">nil</span></span><br><span class="line">            pp.sudogcache = <span class="built_in">append</span>(pp.sudogcache, s)</span><br><span class="line">        &#125;</span><br><span class="line">        unlock(&amp;sched.sudoglock)</span><br><span class="line">        <span class="comment">// If the central cache is empty, allocate a new one.</span></span><br><span class="line">        <span class="comment">// 如果中央缓存为空，则分配一个新的缓存。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(pp.sudogcache) == <span class="number">0</span> &#123;</span><br><span class="line">            pp.sudogcache = <span class="built_in">append</span>(pp.sudogcache, <span class="built_in">new</span>(sudog))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Get the first return from the local cache sudog and update the sudogcache slice</span></span><br><span class="line">    n := <span class="built_in">len</span>(pp.sudogcache)<span class="comment">// 当前缓存中 sudog 的数量</span></span><br><span class="line">    s := pp.sudogcache[n<span class="number">-1</span>]<span class="comment">// 获取最后一个 sudog</span></span><br><span class="line">    pp.sudogcache[n<span class="number">-1</span>] = <span class="literal">nil</span></span><br><span class="line">    pp.sudogcache = pp.sudogcache[:n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">if</span> s.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;acquireSudog: found s.elem != nil in cache&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// De lock</span></span><br><span class="line">    releasem(mp)<span class="comment">// 释放当前的 m （线程）上下文</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="releaseSudog"><a href="#releaseSudog" class="headerlink" title="releaseSudog"></a>releaseSudog</h4><p>releaseSudog is sudog that releases the currently used sudog and balances the sudog of p local cache and sudog of global queue.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">releaseSudog</span><span class="params">(s *sudog)</span></span> &#123;</span><br><span class="line">    mp := acquirem() <span class="comment">// avoid rescheduling to another P</span></span><br><span class="line">    pp := mp.p.ptr()</span><br><span class="line">    <span class="comment">// If the number of sudogs cached locally in p exceeds the maximum length of this slice, balance the general sudog to the global scheme</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pp.sudogcache) == <span class="built_in">cap</span>(pp.sudogcache) &#123;</span><br><span class="line">        <span class="comment">// Transfer half of local cache to the central cache.</span></span><br><span class="line">        <span class="keyword">var</span> first, last *sudog</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(pp.sudogcache) &gt; <span class="built_in">cap</span>(pp.sudogcache)/<span class="number">2</span> &#123;</span><br><span class="line">            n := <span class="built_in">len</span>(pp.sudogcache)</span><br><span class="line">            p := pp.sudogcache[n<span class="number">-1</span>]</span><br><span class="line">            pp.sudogcache[n<span class="number">-1</span>] = <span class="literal">nil</span></span><br><span class="line">            pp.sudogcache = pp.sudogcache[:n<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> first == <span class="literal">nil</span> &#123;</span><br><span class="line">                first = p</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                last.next = p</span><br><span class="line">            &#125;</span><br><span class="line">            last = p</span><br><span class="line">        &#125;</span><br><span class="line">        lock(&amp;sched.sudoglock)</span><br><span class="line">        last.next = sched.sudogcache</span><br><span class="line">        sched.sudogcache = first</span><br><span class="line">        unlock(&amp;sched.sudoglock)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Put the released sudog in the slice of the local cache</span></span><br><span class="line">    pp.sudogcache = <span class="built_in">append</span>(pp.sudogcache, s)</span><br><span class="line">    releasem(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="chansend1"><a href="#chansend1" class="headerlink" title="chansend1"></a>chansend1</h3><p>The sending logic is similar to the receiving logic.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    chansend(c, elem, <span class="literal">true</span>, getcallerpc())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !block &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">		throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> debugChan &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;chansend: chan=&quot;</span>, c, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		racereadpc(c.raceaddr(), callerpc, abi.FuncPCABIInternal(chansend))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// After observing that the channel is not closed, we observe that the channel is</span></span><br><span class="line">	<span class="comment">// not ready for sending. Each of these observations is a single word-sized read</span></span><br><span class="line">	<span class="comment">// (first c.closed and second full()).</span></span><br><span class="line">	<span class="comment">// Because a closed channel cannot transition from &#x27;ready for sending&#x27; to</span></span><br><span class="line">	<span class="comment">// &#x27;not ready for sending&#x27;, even if the channel is closed between the two observations,</span></span><br><span class="line">	<span class="comment">// they imply a moment between the two when the channel was both not yet closed</span></span><br><span class="line">	<span class="comment">// and not ready for sending. We behave as if we observed the channel at that moment,</span></span><br><span class="line">	<span class="comment">// and report that the send cannot proceed.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// It is okay if the reads are reordered here: if we observe that the channel is not</span></span><br><span class="line">	<span class="comment">// ready for sending and then observe that it is not closed, that implies that the</span></span><br><span class="line">	<span class="comment">// channel wasn&#x27;t closed during the first observation. However, nothing here</span></span><br><span class="line">	<span class="comment">// guarantees forward progress. We rely on the side effects of lock release in</span></span><br><span class="line">	<span class="comment">// chanrecv() and closechan() to update this thread&#x27;s view of c.closed and full().</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 快速路径：在不获取锁的情况下检查非阻塞操作是否失败。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 在观察到通道未关闭之后，我们观察到通道未准备好发送。每个观察都是一个单字大小的读取</span></span><br><span class="line">	<span class="comment">//（首先是 c.closed，然后是 full()）。</span></span><br><span class="line">	<span class="comment">// 由于已关闭的通道不能从“准备好发送”转换为“不准备发送”，即使在两个观察之间通道关闭了，</span></span><br><span class="line">	<span class="comment">// 它们也暗示了一个时刻，即在两次观察之间通道既未关闭也未准备好发送。</span></span><br><span class="line">	<span class="comment">// 我们的行为就好像在那个时刻观察到了通道，并报告发送无法进行。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 这里的读取重排是可以的：如果我们观察到通道未准备好发送，然后观察到它未关闭，</span></span><br><span class="line">	<span class="comment">// 那意味着在第一次观察期间通道没有关闭。但是，这里没有保证向前推进。我们依赖于</span></span><br><span class="line">	<span class="comment">// chanrecv() 和 closechan() 中锁释放的副作用来更新该线程对 c.closed 和 full() 的视图。</span></span><br><span class="line">	<span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; full(c) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> t0 <span class="type">int64</span></span><br><span class="line">	<span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">		t0 = cputicks()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 找到等待的接收者。我们将要发送的值直接传递给接收者，绕过通道缓冲区（如果有）。</span></span><br><span class="line">	<span class="comment">// 同上 要么是没有缓存区 要么是缓存区满了</span></span><br><span class="line">	<span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Found a waiting receiver. We pass the value we want to send</span></span><br><span class="line">		<span class="comment">// directly to the receiver, bypassing the channel buffer (if any).</span></span><br><span class="line">		send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通道缓冲区中有空间。将要发送的元素入队。</span></span><br><span class="line">	<span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">		<span class="comment">// Space is available in the channel buffer. Enqueue the element to send.</span></span><br><span class="line">		qp := chanbuf(c, c.sendx)</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			racenotify(c, c.sendx, <span class="literal">nil</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">		c.sendx++</span><br><span class="line">		<span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">			c.sendx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.qcount++</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !block &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在通道上阻塞。某个接收者将完成我们的操作。</span></span><br><span class="line">	<span class="comment">// Block on the channel. Some receiver will complete our operation for us.</span></span><br><span class="line">	gp := getg()</span><br><span class="line">	mysg := acquireSudog()</span><br><span class="line">	mysg.releasetime = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">		mysg.releasetime = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line">	<span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">	mysg.elem = ep</span><br><span class="line">	mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">	mysg.g = gp</span><br><span class="line">	mysg.isSelect = <span class="literal">false</span></span><br><span class="line">	mysg.c = c</span><br><span class="line">	gp.waiting = mysg</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	c.sendq.enqueue(mysg)</span><br><span class="line">	<span class="comment">// Signal to anyone trying to shrink our stack that we&#x27;re about</span></span><br><span class="line">	<span class="comment">// to park on a channel. The window between when this G&#x27;s status</span></span><br><span class="line">	<span class="comment">// changes and when we set gp.activeStackChans is not safe for</span></span><br><span class="line">	<span class="comment">// stack shrinking.</span></span><br><span class="line">	atomic.Store8(&amp;gp.parkingOnChan, <span class="number">1</span>)</span><br><span class="line">	gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, <span class="number">2</span>)</span><br><span class="line">	<span class="comment">// Ensure the value being sent is kept alive until the</span></span><br><span class="line">	<span class="comment">// receiver copies it out. The sudog has a pointer to the</span></span><br><span class="line">	<span class="comment">// stack object, but sudogs aren&#x27;t considered as roots of the</span></span><br><span class="line">	<span class="comment">// stack tracer.</span></span><br><span class="line">	KeepAlive(ep)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// someone woke us up.</span></span><br><span class="line">	<span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">		throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	gp.waiting = <span class="literal">nil</span></span><br><span class="line">	gp.activeStackChans = <span class="literal">false</span></span><br><span class="line">	closed := !mysg.success</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">		blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	mysg.c = <span class="literal">nil</span></span><br><span class="line">	releaseSudog(mysg)</span><br><span class="line">	<span class="keyword">if</span> closed &#123;</span><br><span class="line">		<span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">&quot;chansend: spurious wakeup&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="send"><a href="#send" class="headerlink" title="send"></a>send</h4><p>Send and recv have the same logic, and because a sudog is taken from recvq, it means that the buffer is empty, so the send method does not need to consider adding data to the buffer. Send is simpler than recv, it only needs to exchange data and wake up g.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		<span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">			racesync(c, sg) <span class="comment">// 对于无缓冲通道，执行竞争检测同步操作</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Pretend we go through the buffer, even though</span></span><br><span class="line">			<span class="comment">// we copy directly. Note that we need to increment</span></span><br><span class="line">			<span class="comment">// the head/tail locations only when raceenabled.</span></span><br><span class="line">			<span class="comment">// 假装我们通过缓冲区发送，即使我们直接复制。请注意，只有在启用竞争检测时，我们需要增加头/尾位置。</span></span><br><span class="line">			racenotify(c, c.recvx, <span class="literal">nil</span>) <span class="comment">// 通知竞争检测器接收者已经准备好接收</span></span><br><span class="line">			racenotify(c, c.recvx, sg)  <span class="comment">// 通知竞争检测器发送者已经准备好发送</span></span><br><span class="line">			c.recvx++                   <span class="comment">// 增加接收位置</span></span><br><span class="line">			<span class="keyword">if</span> c.recvx == c.dataqsiz &#123;  <span class="comment">// 循环队列，如果接收位置超出缓冲区范围，则重置为0</span></span><br><span class="line">				c.recvx = <span class="number">0</span></span><br><span class="line">			&#125;</span><br><span class="line">			c.sendx = c.recvx <span class="comment">// c.sendx = (c.sendx+1) % c.dataqsiz // 发送位置等于接收位置（c.sendx = (c.sendx+1) % c.dataqsiz）</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123; <span class="comment">// 如果有要发送的元素</span></span><br><span class="line">		sendDirect(c.elemtype, sg, ep) <span class="comment">// 直接将元素发送给等待的接收者</span></span><br><span class="line">		sg.elem = <span class="literal">nil</span>                  <span class="comment">// 清空元素</span></span><br><span class="line">	&#125;</span><br><span class="line">	gp := sg.g</span><br><span class="line">	unlockf()                     <span class="comment">// 解锁通道</span></span><br><span class="line">	gp.param = unsafe.Pointer(sg) <span class="comment">// 将sudog作为参数存储到Goroutine的param字段中</span></span><br><span class="line">	sg.success = <span class="literal">true</span>             <span class="comment">// 设置发送成功标志</span></span><br><span class="line">	<span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;      <span class="comment">// 如果需要记录释放时间</span></span><br><span class="line">		sg.releasetime = cputicks()</span><br><span class="line">	&#125;</span><br><span class="line">	goready(gp, skip+<span class="number">1</span>) <span class="comment">// 将Goroutine标记为可运行状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="closechan"><a href="#closechan" class="headerlink" title="closechan"></a>closechan</h3><p>Receiving and receiving data is over, and finally the channel is closed.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">&quot;close of nil channel&quot;</span>)) <span class="comment">// close 空 chan  抛出异常</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock(&amp;c.lock) <span class="comment">//获取锁</span></span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">&quot;close of closed channel&quot;</span>)) <span class="comment">// 如果通道已关闭，则释放锁并抛出运行时异常</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		callerpc := getcallerpc()</span><br><span class="line">		racewritepc(c.raceaddr(), callerpc, abi.FuncPCABIInternal(closechan)) <span class="comment">// 执行竞争检测</span></span><br><span class="line">		racerelease(c.raceaddr())                                             <span class="comment">// 释放竞争检测资源</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.closed = <span class="number">1</span> <span class="comment">// 将通道的closed字段设置为1，表示通道已关闭</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> glist gList</span><br><span class="line">	<span class="comment">// 释放所有的读取者（接收者）</span></span><br><span class="line">	<span class="comment">// release all readers</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		sg := c.recvq.dequeue() <span class="comment">// 从接收队列中出队一个等待的sudog</span></span><br><span class="line">		<span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123; <span class="comment">// 如果sudog的elem字段不为nil，表示有接收者正在等待接收数据</span></span><br><span class="line">			typedmemclr(c.elemtype, sg.elem) <span class="comment">// 清空接收者的元素</span></span><br><span class="line">			sg.elem = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">			sg.releasetime = cputicks()</span><br><span class="line">		&#125;</span><br><span class="line">		gp := sg.g</span><br><span class="line">		gp.param = unsafe.Pointer(sg) <span class="comment">// 将sudog作为参数存储到Goroutine的param字段中</span></span><br><span class="line">		sg.success = <span class="literal">false</span>            <span class="comment">// 设置接收失败标志</span></span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquireg(gp, c.raceaddr())</span><br><span class="line">		&#125;</span><br><span class="line">		glist.push(gp) <span class="comment">// 将Goroutine添加到glist中</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 释放所有的写入者（发送者），它们将引发panic</span></span><br><span class="line">	<span class="comment">// release all writers (they will panic)</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		sg := c.sendq.dequeue() <span class="comment">// 从发送队列中出队一个等待的sudog</span></span><br><span class="line">		<span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		sg.elem = <span class="literal">nil</span> <span class="comment">//清空sudog的元素</span></span><br><span class="line">		<span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">			sg.releasetime = cputicks()</span><br><span class="line">		&#125;</span><br><span class="line">		gp := sg.g</span><br><span class="line">		gp.param = unsafe.Pointer(sg) <span class="comment">// 将sudog作为参数存储到Goroutine的param字段中</span></span><br><span class="line">		sg.success = <span class="literal">false</span>            <span class="comment">// 设置发送失败标志</span></span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquireg(gp, c.raceaddr()) <span class="comment">// 执行竞争检测</span></span><br><span class="line">		&#125;</span><br><span class="line">		glist.push(gp) <span class="comment">// 将Goroutine添加到glist中</span></span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;c.lock) <span class="comment">// 释放通道的锁</span></span><br><span class="line">	<span class="comment">// 在释放通道锁后，将所有的Goroutine标记为可运行状态，以便它们可以继续执行</span></span><br><span class="line">	<span class="comment">// Ready all Gs now that we&#x27;ve dropped the channel lock.</span></span><br><span class="line">	<span class="keyword">for</span> !glist.empty() &#123;</span><br><span class="line">		gp := glist.pop()</span><br><span class="line">		gp.schedlink = <span class="number">0</span></span><br><span class="line">		goready(gp, <span class="number">3</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>After chan close, sudog in all blocked recvq and sendq (recvq and sendq have only one queue), clear some data and state of sudog, set gp.param &#x3D; nil, let upper logic know that it is caused by close chan</p>
<p>After waking up all g, g will continue to execute the remaining logic in chansend or chanrecv, that is, to release sudog (which is why closechan does not need to release sudog)</p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>Language expression is always pale. When looking for information on the Internet, I saw two flow charts, which can be seen in combination.</p>
<p>send process</p>
<p><img src="/image/go/chan/send.jpg"></p>
<p>Receiving process (recv)</p>
<p><img src="/image/go/chan/recv.jpg"></p>
<p>转载于 <a target="_blank" rel="noopener" href="https://programming.vip/docs/deeply-understanding-the-principles-of-go-channel-and-select.html">Programming VIP</a></p>
<p>添加了部分注释，翻译了一些英文解释，有问题大家可以添加评论讨论，我会及时更正</p>

  </div>
  </br>
  </br>
  
  <section id="comments" class="comments">
    <div class="valine-comment"></div>
<!--载入js，在</body>之前插入即可-->
<!--Leancloud 操作库:-->
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<!--Valine 的核心代码库-->
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
new Valine({
    el: '.valine-comment',
    app_id: 'aVoW8Ns48PCL9aWpyaraklyz-gzGzoHsz',
    app_key: '5OofdgauZeSJ0SPHIgbbQ6fe',
    placeholder: '',
    visitor: 'true',
  })
</script>
  </section>
  
</article>
    </main>
    <footer id="footer">
  Copyright &copy;
  2023
  Yu Peng
  
  
    <a class="social-links" target="_blank" rel="noopener" href="https://github.com/yuhua2000"><i class="blogfont"><img src="https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/github.svg" alt="GitHub" width="16" height="16"> </i></a>
  
    <a class="social-links" target="_blank" rel="noopener" href="https://leetcode.cn/u/yu-peng-f"><i class="blogfont"><img src="https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/leetcode.svg" alt="LeetCode" width="16" height="16"> </i></a>
  
    <a class="social-links" href="mailto:2651034096@qq.com"><i class="blogfont"><img src="https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/gmail.svg" alt="Mail" width="16" height="16"> </i></a>
  
  
</footer>
    <!-- scripts -->

<script src="/scripts/main.js"></script>

  </body>
</html>