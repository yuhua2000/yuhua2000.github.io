<!DOCTYPE html>
<html  lang=en>
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  
    
    <link rel="shortcut icon" href="/images/favicon.ico ">
    
    
    <link rel="icon" type="image/png" href="/images/favicon-android.png " sizes="192x192">
    
    
    <link rel="apple-touch-icon" href="/images/favicon-apple.png " sizes="180x180">
    
  
  <!-- title -->
  <title>Yu Peng blog 第一章 概述 </title>
  <!-- styles -->
  <!-- styles -->

<link rel="stylesheet" href="/styles/global.css">

  <!-- rss -->
  
<meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <header id="header">
  
  <nav class="menu menu--right">
  
    <a class="menu__item" href="/">主页</a>
    <a class="menu__item" href="/archives/">归档</a>
    <a class="menu__item" href="/categories/">专题</a>
    <a class="menu__item" href="/tags/">标签</a>
    <a class="menu__item" href="/works/">作品</a>
    <a class="menu__item" href="/about/">关于</a>
  </nav>
</header>
    <main>
      <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post__header">
  <h1 class="post__title">第一章 概述</h1>
  
  
  <div class="post__meta">
    
<time class="post__date" datetime="2024-06-27T12:00:37.000Z" itemprop="datePublished">
  
  <i class="blogfont">&#xedff;</i>
  
  2024-06-27 20:00:37
</time>

    
<div class="post__category">
  <i class="blogfont">&#xe62d;</i>
  <a class="category-link" href="/categories/TCP-IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71/">TCP/IP详解 卷1</a>
</div>
  

    
<div class="post__tag">
  <i class="blogfont">&#xe7ec;</i>
  <a class="tag-link-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a>, <a class="tag-link-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a>
</div>


    <div id="/2024/06/27/tcp-ip/chapter1/index/" class="leancloud_visitors post__stat" data-flag-title="第一章 概述">
  <i class="blogfont">&#xe672;</i>
  <span class="leancloud-visitors-count">loading...</span>
</div>
  </div>
</header>
  <aside class="post__aside">
  <div class="post__actions">
    <a id="backTop" class="post__top" href="javascript:">
      <i class="blogfont">&#xe6b1;</i><!-- Top -->
    </a>
    <a id="share" class="post__share" href="javascript:">
      <i class="blogfont">&#xe6c1;</i>
    </a>
  </div>
  <ol class="post__toc"><li class="post__toc-item post__toc-level-1"><a class="post__toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="post__toc-text">概述</span></a><ol class="post__toc-child"><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82"><span class="post__toc-text">网络分层</span></a></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#TCP-x2F-IP%E7%9A%84%E5%88%86%E5%B1%82"><span class="post__toc-text">TCP&#x2F;IP的分层</span></a></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="post__toc-text">互联网的地址</span></a></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F"><span class="post__toc-text">域名系统</span></a></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#%E5%B0%81%E8%A3%85"><span class="post__toc-text">封装</span></a></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#%E5%88%86%E7%94%A8"><span class="post__toc-text">分用</span></a></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#%E5%AE%A2%E6%88%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9E%8B"><span class="post__toc-text">客户-服务器模型</span></a></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="post__toc-text">端口号</span></a></li></ol></li></ol>
</aside>
  <div class="post__content" itemprop="articleBody">
    <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h2><p>网络协议通常分不同层次进行开发，每一层分别负责不同的通信功能。一个协议族，比如 TCP&#x2F;IP，是一组不同层次上的多个协议的组合。 TCP&#x2F;IP通常被认为是一个四层协议系统，如图 1-1所示。</p>
<p><img src="/images/tcp-ip/1-1.jpg"><br>图1-1 TCP&#x2F;IP协议族的四个层次</p>
<p>每一层负责不同的功能：</p>
<ul>
<li><p>链路层，有时也称作数据链路层或网络接口层，通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。它们一起处理与电缆（或其他任何传输媒介）的物理接口细节。</p>
</li>
<li><p>网络层，有时也称作互联网层，处理分组在网络中的活动， </p>
</li>
<li><p>运输层主要为两台主机上的应用程序提供端到端的通信。在 TCP&#x2F;IP协议族中，有两个互不相同的传输协议：TCP（传输控制协议）和UDP（用户数据报协议）。</p>
</li>
<li><p>应用层负责处理特定的应用程序细节。</p>
</li>
</ul>
<p>假设在一个局域网（LAN）如以太网中有两台主机，二者都运行FTP协议，图1-2列出了该过程所涉及到的所有协议。</p>
<p><img src="/images/tcp-ip/1-2.jpg"><br>图1-2 局域网上运行FTP的两台主机</p>
<p>网络接口层和应用层的目的是很显然的—前者处理有关通信媒介的细节（以太网、令牌环网等），而后者处理某个特定的用户应用程序（ FTP、Telnet等）。但是，从表面上看，网络层和运输层之间的区别不那么明显。为什么要把它们划分成两个不同的层次呢？为了理解这一点，我们必须把视野从单个网络扩展到一组网络。</p>
<p>构造互连网最简单的方法是把两个或多个网络通过路由器进行连接。它是一种特殊的用于网络互连的硬件盒。路由器的好处是为不同类型的物理网络提供连接：以太网、令牌环网、对点的链接和FDDI（光纤分布式数据接口）等等。</p>
<p>图1-3是一个包含两个网络的互连网：一个以太网和一个令牌环网，通过一个路由器互相连接。尽管这里是两台主机通过路由器进行通信，实际上以太网中的任何主机都可以与令牌环网中的任何主机进行通信。</p>
<p>在图 1-3中，我们可以划分出端系统（ End system ）（两边的两台主机）和中间系统（Intermediate system）（中间的路由器）。应用层和运输层使用端到端（ End-to-end）协议。在图中，只有端系统需要这两层协议。但是，网络层提供的却是逐跳（Hop-by-hop）协议，两个端系统和每个中间系统都要使用它。</p>
<p><img src="/images/tcp-ip/1-3.jpg"><br>图1-3 通过路由器连接的两个网络</p>
<p>在 TCP&#x2F;IP 协议族中，网络层 IP 提供的是一种不可靠的服务。也就是说，它只是尽可能快地把分组从源结点送到目的结点，但是并不提供任何可靠性保证。而另一方面， TCP 在不可靠的 IP 层上提供了一个可靠的运输层。为了提供这种可靠的服务， TCP 采用了超时重传、发送和接收端到端的确认分组等机制。由此可见，运输层和网络层分别负责不同的功能。</p>
<p>互联网的目的之一是在应用程序中隐藏所有的物理细节。虽然这一点在图 1-3 由两个网络组成的互联网中并不很明显，但是应用层不能关心（也不关心）一台主机是在以太网上，而另一台主机是在令牌环网上，它们通过路由器进行互连。随着增加不同类型的物理网络，可能会有20个路由器，但应用层仍然是一样的。物理细节的隐藏使得互联网功能非常强大，也非常有用。</p>
<p>连接网络的另一个途径是使用网桥。网桥是在链路层上对网络进行互连，而路由器则是在网络层上对网络进行互连。网桥使得多个局域网（ L A N）组合在一起，这样对上层来说就好像是一个局域网。</p>
<p>TCP &#x2F;IP倾向于使用路由器而不是网桥来连接网络，因此我们将着重介绍路由器。</p>
<h2 id="TCP-x2F-IP的分层"><a href="#TCP-x2F-IP的分层" class="headerlink" title="TCP&#x2F;IP的分层"></a>TCP&#x2F;IP的分层</h2><p><img src="/images/tcp-ip/1-4.jpg"><br>图1-4 TCP&#x2F;IP协议族中不同层次的协议</p>
<p>TCP和UDP是两种最为著名的运输层协议，二者都使用 I P作为网络层协议。</p>
<p>UDP为应用程序发送和接收数据报。一个数据报是指从发送方传输到接收方的一个信息单元（例如，发送方指定的一定字节数的信息）。但是与TCP不同的是，UDP是不可靠的，它不能保证数据报能安全无误地到达最终目的。</p>
<p>IP是网络层上的主要协议，同时被 TCP和UDP使用。TCP和UDP的每组数据都通过端系统和每个中间路由器中的IP层在互联网中进行传输。在图1-4中，我们给出了一个直接访问IP的应用程序。这是很少见的，但也是可能的。</p>
<p>ICMP是IP协议的附属协议。IP层用它来与其他主机或路由器交换错误报文和其他重要信息。</p>
<p>IGMP是Internet组管理协议。它用来把一个 UDP数据报多播到多个主机。</p>
<p>ARP（地址解析协议）和RARP（逆地址解析协议）是某些网络接口（如以太网和令牌环网）使用的特殊协议，用来转换 I   P层和网络接口层使用的地址。</p>
<h2 id="互联网的地址"><a href="#互联网的地址" class="headerlink" title="互联网的地址"></a>互联网的地址</h2><p>互联网上的每个接口必须有一个唯一的 Internet地址（也称作 IP地址）。IP地址长 32 bit。Internet地址并不采用平面形式的地址空间，如 1、2、3等。IP地址具有一定的结构，五类不同的互联网地址格式如图1 - 5所示。</p>
<p><img src="/images/tcp-ip/1-5.jpg"><br>图1-5 五类互联网地址</p>
<h2 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h2><p>尽管通过I P地址可以识别主机上的网络接口，进而访问主机，但是人们最喜欢使用的还是主机名。在 TCP&#x2F;IP领域中，域名系统（DNS）是一个分布的数据库，由它来提供IP地址和主机名之间的映射信息。</p>
<p>现在，我们必须理解，任何应用程序都可以调用一个标准的库函数来查看给定名字的主机的IP地址。类似地，系统还提供一个逆函数—给定主机的IP地址，查看它所对应的主机名。大多数使用主机名作为参数的应用程序也可以把IP地址作为参数。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>当应用程序用 TCP 传送数据时，数据被送入协议栈中，然后逐个通过每一层直到被当作一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息（有时还要增加尾部信息），该过程如图 1-7 所示。TCP传给I P的数据单元称作 TCP报文段或简称为 TCP 段（TCP segment）。I P传给网络接口层的数据单元称作 IP数据报(IP datagram)。通过以太网传输的比特流称作帧(Frame)。</p>
<p>所有的Internet标准和大多数有关TCP&#x2F;IP的书都使用octet这个术语来表示字节。使用这个过分雕琢的术语是有历史原因的，因为TCP&#x2F;IP的很多工作都是在DEC-10系统上进行的，但是它并不使用8 bit的字节。由于现在几乎所有的计算机系统都采用8 bit的字节，因此我们在本书中使用字节（byte）这个术语。</p>
<p><img src="/images/tcp-ip/1-7.jpg"><br>图1-7 数据进入协议栈时的封装过程</p>
<p>UDP数据与TCP数据基本一致。唯一的不同是 UDP传给IP的信息单元称作 UDP数据报（UDP datagram），而且U D P的首部长为8字节。</p>
<p>网络接口分别要发送和接收 IP、ARP和RARP数据，因此也必须在以太网的帧首部中加入某种形式的标识，以指明生成数据的网络层协议。为此，以太网的帧首部也有一个 16 bit的帧类型域。</p>
<h2 id="分用"><a href="#分用" class="headerlink" title="分用"></a>分用</h2><p>当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议。这个过程称作分用（Demultiplexing），图1-8显示了该过程是如何发生的。</p>
<p><img src="/images/tcp-ip/1-8.jpg"><br>图1-8 以太网数据帧的分用过程</p>
<p>这些分层协议盒并不都是完美的。</p>
<h2 id="客户-服务器模型"><a href="#客户-服务器模型" class="headerlink" title="客户-服务器模型"></a>客户-服务器模型</h2><p>大部分网络应用程序在编写时都假设一端是客户，另一端是服务器，其目的是为了让服务器为客户提供一些特定的服务。可以将这种服务分为两种类型：重复型或并发型。重复型服务器通过以下步骤进行交互</p>
<p>I1. 等待一个客户请求的到来。<br>I2. 处理客户请求。<br>I3. 发送响应给发送请求的客户。<br>I4. 返回I 1步。  </p>
<p>重复型服务器主要的问题发生在 I 2状态。在这个时候，它不能为其他客户机提供服务。<br>相应地，并发型服务器采用以下步骤：</p>
<p>C1. 等待一个客户请求的到来。<br>C2. 启动一个新的服务器来处理这个客户的请求。在这期间可能生成一个新的进程、任务或线程，并依赖底层操作系统的支持。这个步骤如何进行取决于操作系统。生成的新服务器对客户的全部请求进行处理。处理结束后，终止这个新服务器。<br>C3. 返回C 1步。  </p>
<p>并发服务器的优点在于它是利用生成其他服务器的方法来处理客户的请求。也就是说，每个客户都有它自己对应的服务器。如果操作系统允许多任务，那么就可以同时为多个客户服务。</p>
<p>对服务器，而不是对客户进行分类的原因是因为对于一个客户来说，它通常并不能够辨别自己是与一个重复型服务器或并发型服务器进行对话。</p>
<h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><p>TCP和UDP采用16 bit的端口号来识别应用程序</p>
<p>保留端口号<br>Unix系统有保留端口号的概念。只有具有超级用户特权的进程才允许给它自己分配一个保留端口号。</p>

  </div>
  </br>
  </br>
  
  <section id="comments" class="comments">
    <div class="valine-comment"></div>
<!--载入js，在</body>之前插入即可-->
<!--Leancloud 操作库:-->
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<!--Valine 的核心代码库-->
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
new Valine({
    el: '.valine-comment',
    app_id: 'aVoW8Ns48PCL9aWpyaraklyz-gzGzoHsz',
    app_key: '5OofdgauZeSJ0SPHIgbbQ6fe',
    placeholder: '',
    visitor: 'true',
  })
</script>
  </section>
  
</article>
    </main>
    <footer id="footer">
  Copyright &copy;
  2023
  Yu Peng
  
  
    <a class="social-links" target="_blank" rel="noopener" href="https://github.com/yuhua2000"><i class="blogfont"><img src="https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/github.svg" alt="GitHub" width="16" height="16"> </i></a>
  
    <a class="social-links" target="_blank" rel="noopener" href="https://leetcode.cn/u/yu-peng-f"><i class="blogfont"><img src="https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/leetcode.svg" alt="LeetCode" width="16" height="16"> </i></a>
  
    <a class="social-links" href="mailto:2651034096@qq.com"><i class="blogfont"><img src="https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/gmail.svg" alt="Mail" width="16" height="16"> </i></a>
  
  
</footer>
    <!-- scripts -->

<script src="/scripts/main.js"></script>

  </body>
</html>